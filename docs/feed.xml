<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-06-15T14:43:33-03:00</updated><id>/feed.xml</id><title type="html">Igor Montagner</title><subtitle>Igor&apos;s personal and academic website. </subtitle><entry><title type="html">Criando um editor de texto - parte 3</title><link href="/editor-de-texto/2024/06/15/editor-de-texto-3.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 3" /><published>2024-06-15T00:00:00-03:00</published><updated>2024-06-15T00:00:00-03:00</updated><id>/editor-de-texto/2024/06/15/editor-de-texto-3</id><content type="html" xml:base="/editor-de-texto/2024/06/15/editor-de-texto-3.html"><![CDATA[<p>Agora chegamos na parte interessante que vai juntar novidades tanto de terminal (como dispositivo de hardware) quanto programação funcional. Vejamos:</p>

<ol>
  <li>gleam não tem estado. Ou seja, vai ser necessário guardar quais linhas estão na tela e quais estão fora <strong>sem modificar nenhuma variável</strong>. Além disso, precisamos persistir essas modificações enquanto o usuário interage com o programa.</li>
  <li>até agora só enviamos comandos para o terminal (via escape codes escritos na saída padrão). Agora vamos <strong>receber</strong> esses comandos também via entrada padrão.</li>
</ol>

<p>Vamos tratar um problema de cada vez, começando com como guardar o estado do nosso editor.</p>

<h2 id="representando-o-estado-atual-do-editor">Representando o estado atual do editor</h2>

<p>A primeira parte é guardar quais linhas estão dentro e fora da tela. A imagem abaixo ajuda a entender um pouco a dinâmica de um programa que mostra um arquivo no terminal.</p>

<p><img src="/assets/editor-de-texto/linhas-tela.png" alt="Ilustração de um arquivo sendo mostrado no terminal" /></p>

<p>Logo, precisamos não só de uma lista de linhas, mas de 3:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">before</code> guarda as linhas que estão <strong>antes</strong> do trecho atualmente mostrado na tela. É vazio se a primeira linha está sendo mostrada ou se o arquivo for menor que o número de linhas do terminal</li>
  <li><code class="language-plaintext highlighter-rouge">screen</code> guarda as linhas que estão sendo mostradas na tela <strong>neste momento</strong></li>
  <li><code class="language-plaintext highlighter-rouge">after</code> guarda as linhas que estão <strong>depois</strong> do trecho mostrado na tela atualmente. É vazio se a última linha está sendo mostrada ou se o arquivo for menor que o número de linhas do terminal</li>
</ul>

<p>Uma vantagem dessa representação é que rolar a tela é muito fácil!</p>

<ul>
  <li>para descer a tela precisamos transferir a última linha de <code class="language-plaintext highlighter-rouge">screen</code> para o início de <code class="language-plaintext highlighter-rouge">after</code> e transferir a última de <code class="language-plaintext highlighter-rouge">before</code> para o início de <code class="language-plaintext highlighter-rouge">screen</code>.</li>
  <li>para subir a tela precisamos transferir a primeira linha de <code class="language-plaintext highlighter-rouge">screen</code> para o fim de <code class="language-plaintext highlighter-rouge">before</code> e transferir a primeira de <code class="language-plaintext highlighter-rouge">after</code> para o fim de <code class="language-plaintext highlighter-rouge">screen</code>.</li>
</ul>

<p><em>gleam</em> possui o tipo <a href="https://hexdocs.pm/gleam_stdlib/gleam/queue.html">queue</a>, que permite adicionar/remover elementos de maneira eficiente no início e fim da coleção de dados. Portanto, o estado do nosso programa será uma tripla com esses três elementos.</p>

<pre><code class="language-gleam">type TermState {
  TermState(
    before: queue.Queue(String),
    screen: queue.Queue(String),
    after: queue.Queue(String),
  )
}
</code></pre>

<p>Esse estado agora será passado para a função <code class="language-plaintext highlighter-rouge">input_loop</code> e pode ser modificado pela entrada do usuário. Iniciamos o loop principal como mostrado abaixo:</p>

<pre><code class="language-gleam">let st =
TermState(
  queue.new(),
  queue.from_list(list.take(contents_split_lines, nlines)),
  queue.from_list(list.drop(contents_split_lines, nlines)),
)
terminal.move_cursor(0, 0)

terminal.raw_mode_enter()
input_loop(st)
terminal.raw_mode_end()
</code></pre>

<p>Rolar a tela para baixo pode ser implementado, portanto, com o código abaixo.</p>

<pre><code class="language-gleam">case queue.pop_back(state.before) {
	Ok(#(line_show, new_before)) -&gt; {
	  io.print("\u{1b}[1T") // escape code para o terminal rolar para baixo
	  terminal.move_cursor(0, 0)
	  io.print(line_show)
	  let assert Ok(#(line_hide, new_screen)) = queue.pop_back(state.screen)
	  input_loop(TermState(
		new_before,
		queue.push_front(new_screen, line_show),
		queue.push_front(state.after, line_hide),
	  ))
	}
	_ -&gt; input_loop(state)
</code></pre>

<h2 id="recebendo-teclas-não-alfanuméricas">Recebendo teclas não alfanuméricas</h2>

<p>Agora que já podemos rolar a tela precisamos ler as setinhas do teclado e completar a funcionalidade que precisamos implementar. Felizmente essa é uma tarefa fácil.</p>

<p>Os mesmos códigos que enviamos para o terminal podem ser recebidos dependendo das teclas pressionadas. Os que nos interessam são os seguintes:</p>

<p>| Tecla          | Escape Code |
| ————– | ———– |
| CURSOR UP      | <code class="language-plaintext highlighter-rouge">ESC [ A</code>   |
| CURSOR DOWN    | <code class="language-plaintext highlighter-rouge">ESC [ B</code>   |
| CURSOR FORWARD | <code class="language-plaintext highlighter-rouge">ESC [ C</code>   |
| CURSOR BACK    | <code class="language-plaintext highlighter-rouge">ESC [ D</code>   |
Podemos fazer isso mudando a função <code class="language-plaintext highlighter-rouge">get_key</code> que construímos anteriormente. Agora ele pode retornar ou uma letra (tipo <code class="language-plaintext highlighter-rouge">String</code>) ou um comando para mover o cursor. Conseguimos representar isso com os seguintes tipos em <em>gleam</em>. Note que incluímos a possibilidade <code class="language-plaintext highlighter-rouge">UNKNOWN</code> para caso algum comando não suportado (ainda) seja enviado pelo terminal.</p>

<pre><code class="language-gleam">pub type CursorDirection {
  UP
  DOWN
  LEFT
  RIGHT
}

pub type Key {
  Letter(char: String)
  CursorMovement(dir: CursorDirection)
  UNKNOWN
}
</code></pre>

<p>Nossa função <code class="language-plaintext highlighter-rouge">get_key</code> muda para a seguinte. Agora ela devolve o tipo <code class="language-plaintext highlighter-rouge">Key</code> e checa se o caractere lido é um <code class="language-plaintext highlighter-rouge">ESC</code>. Se, for chama a função <code class="language-plaintext highlighter-rouge">read_escape_sequence</code> que faz a leitura do restante do escape code. Se não só devolve o caractere lido com o construtor <code class="language-plaintext highlighter-rouge">Letter</code>.</p>

<pre><code class="language-gleam">pub fn get_key() -&gt; Key {
  case get_chars("", 1) {
    "\u{1b}" -&gt; read_escape_sequence()
  	letter -&gt; Letter(letter)
  }
}

fn read_escape_sequence() {
	get_chars("", 1) // read [
	case get_chars("", 1) {
		"A" -&gt; CursorMovement(UP)
		"B" -&gt; CursorMovement(DOWN)
		"C" -&gt; CursorMovement(RIGHT)
		"D" -&gt; CursorMovement(LEFT)
		_ -&gt; UNKNOWN
	}
}
</code></pre>

<h2 id="juntando-tudo">Juntando tudo</h2>

<p>Para juntar tudo basta mexer em <code class="language-plaintext highlighter-rouge">input_loop</code> para que o estado seja passado sempre na função recursiva e que chequemos as setas além de letras. Veja abaixo uma parte dessa função.</p>

<p>Um ponto interessante é que se não há nenhuma alteração no estado do programa basta fazer a chamada recursiva com o mesmo estado que foi recebido. É tudo bem claro e não há mudanças “escondidas”.</p>

<pre><code class="language-gleam">fn input_loop(state: TermState) {
  case terminal.get_key() {
    terminal.CursorMovement(terminal.UP) -&gt; {
      case queue.pop_back(state.before) {
        Ok(#(line_show, new_before)) -&gt; {
          io.print("\u{1b}[1T")
          terminal.move_cursor(0, 0)
          io.print(line_show)
          let assert Ok(#(line_hide, new_screen)) = queue.pop_back(state.screen)
          input_loop(TermState(
            new_before,
            queue.push_front(new_screen, line_show),
            queue.push_front(state.after, line_hide),
          ))
        }
        _ -&gt; input_loop(state)
      }
    }
	// checar seta para baixo
	terminal.Letter("q") -&gt; Nil
    _ -&gt; input_loop(state)
}
</code></pre>

<p>Um passo interessante aqui seria reorganizar esse código em módulos para podermos deixar o código mais legível e organizado. Iremos fazer isso na próxima parte, já que precisaremos extender o estado do editor para incluir posição do cursor.</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[Agora chegamos na parte interessante que vai juntar novidades tanto de terminal (como dispositivo de hardware) quanto programação funcional. Vejamos:]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 2</title><link href="/editor-de-texto/2024/06/01/editor-de-texto-2.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 2" /><published>2024-06-01T00:00:00-03:00</published><updated>2024-06-01T00:00:00-03:00</updated><id>/editor-de-texto/2024/06/01/editor-de-texto-2</id><content type="html" xml:base="/editor-de-texto/2024/06/01/editor-de-texto-2.html"><![CDATA[<p>O próximo passo da série de editor de texto em linha de comando é receber argumentos na linha de comando e abrir arquivos. Vamos já preparar o terreno também para</p>

<p>Receber argumentos é bem simples. O pacote <a href="https://hexdocs.pm/argv/">argv</a> faz isso e usar com <em>pattern matching</em> faz o código ficar bem legível. Veja abaixo a nova função <code class="language-plaintext highlighter-rouge">main</code>.</p>

<pre><code class="language-gleam">pub fn main() {
  case argv.load().arguments {
    [filename] -&gt; start_editor(filename)
    _ -&gt; io.println("Usage: file_viewer filename")
  }
</code></pre>

<p>A função <code class="language-plaintext highlighter-rouge">start_editor</code> faz a leitura do arquivo passado na linha de comando e o mostra na saída. Também bem simples, cortesia do pacote <a href="https://hexdocs.pm/simplifile/">simplifile</a> :) Um novidade aqui é o módulo <code class="language-plaintext highlighter-rouge">terminal</code>. Colocamos as funções desenvolvidas na parte anterior nesse arquivo para ficar mais organizado.</p>

<pre><code class="language-gleam">fn start_editor(filename) {
  let assert Ok(contents) = simplifile.read(filename)

  terminal.clear()
  io.print(contents)
  terminal.move_cursor(0, 0)
  terminal.raw_mode_enter()
  input_loop()
  terminal.raw_mode_end()
  Nil
}
</code></pre>

<p>Isso já faz algo bem básico: mostra um arquivo na saída do terminal e espera pela tecla <code class="language-plaintext highlighter-rouge">Q</code> para terminar o programa. Porém, se o arquivo for maior que o tamanho do terminal a tela rola e não conseguimos ver o começo! O terminal automaticamente quebra linhas quando enviamos dados, porém ao criar um editor queremos controlar essas quebras.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">stty</code> também devolve o tamanho do terminal. Então podemos adicionar a função <code class="language-plaintext highlighter-rouge">get_size</code> abaixo em <code class="language-plaintext highlighter-rouge">terminal.gleam</code> para capturar o tamanho atual do terminal. O comando <code class="language-plaintext highlighter-rouge">let assert</code> usa <em>pattern matching</em> e dá erro se o padrão não bater. É uma maneira meio feia de se tratar o erro, mas deixa bem claro que <strong>se falhar o programa vai crashar</strong>.</p>

<pre><code class="language-gleam">pub fn get_size() {
  let assert Ok(output) = shellout.command("stty", ["size"], ".", [])
  let assert Ok(#(lines, cols)) = string.split_once(output, " ")

  let assert Ok(lines) = int.base_parse(lines, 10)
  let assert Ok(cols) = int.base_parse(string.trim(cols), 10)

  #(lines, cols)
}
</code></pre>

<p>Agora o desafio vai ser transformar a string <code class="language-plaintext highlighter-rouge">contents</code> (com o conteúdo do arquivo) em uma lista de strings em que cada uma tenha no máximo a largura atual do terminal. Isso nos ajuda a contar quantas linhas vão ser efetivamente usadas quando mostrarmos o arquivo.</p>

<p>O pacote <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html">gleam/string</a> já tem uma função <code class="language-plaintext highlighter-rouge">split</code>, então o trabalho maior será processar cada linha do arquivo e, se necessário, criar uma nova lista com um ou mais “linhas virtuais” para aquela linha do arquivo. Veja um exemplo abaixo em que o tamanho máximo seria 5.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrada
["abcdefgh", "abc"]
Saída
["abcde", "fgh", "abc"]
</code></pre></div></div>

<p>Esse algoritmo vai ficar bem diferente por estarmos escrevendo em uma linguagem funcional. Pra começar <em>Gleam</em> não tem loops, é tudo recursivo. Além disso todas variáveis são imutáveis, então não dá para simplesmente adicionar ou remover elementos de uma lista. É necessário <em>criar uma nova lista sem/com o elemento</em>! Apesar de isso parecer tornar o código muito mais complicado, eu vou argumentar que na verdade ele fica mais simples. Sim, isso mesmo. Vem comigo.</p>

<p>Vamos dividir o algoritmo de criar as “linhas virtuais” em 3 casos:</p>

<ol>
  <li>a lista de linhas está vazia. Devolva então uma lista vazia.</li>
  <li>o primeiro elemento tem tamanho menor que o máximo <code class="language-plaintext highlighter-rouge">M</code>. Crie uma nova lista com o primeiro elemento intacto e chame recursivo no resto da lista.</li>
  <li>o primeiro elemento tem tamanho maior que o máximo <code class="language-plaintext highlighter-rouge">M</code>. Crie uma nova lista com três “pedaços”:</li>
  <li>os primeiros <code class="language-plaintext highlighter-rouge">M</code> elementos do atual</li>
  <li>chame recursivo em uma nova lista com o restante do elemento atual mais o restante da lista original.</li>
</ol>

<p>Pronto. Só isso! Veja agora o algoritmo <code class="language-plaintext highlighter-rouge">split_long_lines</code> escrito em <em>Gleam</em></p>

<pre><code class="language-gleam">fn split_long_lines(line_list, max_length) {
  case line_list {
    [] -&gt; []
    [current, ..rest] -&gt; {
      let curr_length = string.length(current)
      case curr_length {
        l if l &lt; max_length -&gt; [current, ..split_long_lines(rest, max_length)]
        l -&gt; {
          [string.slice(current, 0, max_length), ..split_long_lines([string.drop_left(current, max_length), ..rest], max_length)]
        }
      }
    }
  }
}
</code></pre>

<p>A descrição em código é basicamente igual ao código :D Três casos, cada um retornando uma nova lista. Só é realmente feito algo quando a linha atual é maior que o tamanho máximo.</p>

<p>Isso já praticamente resolve nosso problema! Com as linhas agora com tamanho máximo na largura do terminal, podemos só chamar <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#take"><code class="language-plaintext highlighter-rouge">list.take</code></a> e pegar as primeiras <code class="language-plaintext highlighter-rouge">nlines</code>.  Veja o resultado final abaixo.</p>

<pre><code class="language-gleam">fn start_editor(filename) {
  let assert Ok(contents) = simplifile.read(filename)
  let #(nlines, ncols) = terminal.get_size()
  let contents_split_lines = split_line_max_length(contents, ncols)

  terminal.clear()
  io.print(string.join(list.take(contents_split_lines, nlines), "\n"))
  terminal.move_cursor(0, 0)

  terminal.raw_mode_enter()
  input_loop()
  terminal.raw_mode_end()
  Nil
}
</code></pre>

<p>Agora são mostradas as primeiras linhas do arquivo até encher o terminal. O próximo passo é agora ler as setinhas do terminal e reagir, mostrando mais linhas no topo ou na parte de baixo da tela. Vamos fazer isso no próximo texto, já que precisaremos guardar o <strong>estado</strong> (trecho do arquivo sendo mostrado) do programa durante sua execução. E como só temos variáveis constantes, vai ser necessário pensar um pouco mais sobre a organização do nosso programa. Até mais.</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[O próximo passo da série de editor de texto em linha de comando é receber argumentos na linha de comando e abrir arquivos. Vamos já preparar o terreno também para]]></summary></entry><entry><title type="html">Eu quero apoiar projetos de código aberto</title><link href="/open-source/2024/05/31/apoio-codigo-aberto.html" rel="alternate" type="text/html" title="Eu quero apoiar projetos de código aberto" /><published>2024-05-31T00:00:00-03:00</published><updated>2024-05-31T00:00:00-03:00</updated><id>/open-source/2024/05/31/apoio-codigo-aberto</id><content type="html" xml:base="/open-source/2024/05/31/apoio-codigo-aberto.html"><![CDATA[<p>Há algum tempo parei de pagar o Dropbox Plus, mas ainda não vejo problema nenhum de usar Netflix, Crunchyroll, Amazon Prime e etc. Esses serviços são oferecidos por grandes empresas e baseados primariamente em software fechado. Em compensação, mal pago um tostão para os desenvolvedores de softwares que uso há anos, como Fedora, Ubuntu, Krita, Inkscape e Firefox. Sem falar em outros mais recentes que admiro, como Gleam, UBPorts e Nextcloud.</p>

<p>Tenho pensado sobre isso após ler alguns posts sobre degoogling no <a href="https://fostodon.org">fosstodon</a>… Esses e muitos outros projetos precisam de mais recursos para continuarem existindo e melhorando, porém hoje eu não contribuo financeiramente para isso. Não faz nenhum sentido eu pagar anos de Dropbox e não contribuir nada para Nextcloud, por exemplo.</p>

<p>É verdade que já fiz uma porção de contribuições a projetos abertos, porém não é a mesma coisa. Um PR aceito é uma melhoria que a comunidade recebe, mas ainda assim é necessário que um mantenedor do projeto revise, aceite e mantenha esse código funcionando ao longo do tempo. E esse mantenedor não tem o meu apoio. Ele tem até mais trabalho, já que precisa gerenciar as contribuições externas e revisar código. E essas duas coisas são bem menos interessantes que escrever código novo e implementar novas funcionalidades.</p>

<p>Por isso, decidi começar a apoiar os projetos que mais uso nos últimos tempos. Segue uma lista inicial.</p>

<ul>
  <li>Gleam - linguagem funcional estranhamente boa e confortável para uso.</li>
  <li>TabDigital - provedor de serviços Nextcloud</li>
  <li>Termux - uso muito para transformar meu tablet em um dispositivo útil para trabalho</li>
</ul>

<p>Novos projetos provavelmente irão aparecer, mas esses eu gostaria de contribuir agora. São importantes para mim atualmente e eu gostaria de ajudar esses projetos a serem mais sustentáveis.</p>]]></content><author><name></name></author><category term="open-source" /><summary type="html"><![CDATA[Há algum tempo parei de pagar o Dropbox Plus, mas ainda não vejo problema nenhum de usar Netflix, Crunchyroll, Amazon Prime e etc. Esses serviços são oferecidos por grandes empresas e baseados primariamente em software fechado. Em compensação, mal pago um tostão para os desenvolvedores de softwares que uso há anos, como Fedora, Ubuntu, Krita, Inkscape e Firefox. Sem falar em outros mais recentes que admiro, como Gleam, UBPorts e Nextcloud.]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 1</title><link href="/editor-de-texto/2024/05/23/editor-de-texto-1.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 1" /><published>2024-05-23T00:00:00-03:00</published><updated>2024-05-23T00:00:00-03:00</updated><id>/editor-de-texto/2024/05/23/editor-de-texto-1</id><content type="html" xml:base="/editor-de-texto/2024/05/23/editor-de-texto-1.html"><![CDATA[<p>Eu gosto de editores de texto.Mesmo. Já testei uma porção deles e de todos os tipos, desde neovim e Emacs até os menos conhecidos como helix e micro. Também uso editores de texto GUI e já experimentei um monte deles. Aliás, minhas contribuições mais complexas no elementary linux foram justamente no editor de texto Code.</p>

<p>Resolvi então explorar como construir um editor de texto do zero. E não só isso: um editor de texto que funcione no terminal. Meus dois objetivos com isso são</p>

<ol>
  <li>explorar os tipos de algoritmos envolvidos na criação de um editor de texto</li>
  <li>usar a linguagem funcional Gleam para construir um programa complexo</li>
</ol>

<p>A cada novo texto irei contando um pouco deste processo e teremos uma versão mais sofisticada do editor. Aliás, nas primeiras versões nosso “editor” não vai nem modificar os arquivos, só mostrá-los.</p>

<p>Essa é uma outra vantagem de construir no terminal: ter a chance de se aprofundar em problemas que já são resolvidos completamente por outras bibliotecas. Por exemplo, um GtkSourceView já possui recursos prontos para syntax highlight e auto complete. Isso ajuda a criar um editor rápido e poupa um grande trabalho, mas não necessariamente ajuda a aprender como resolver esses problemas.</p>

<p>Essa parte 1 da série explica um pouco sobre o que é um terminal em sistemas POSIX e como podemos controlá-lo para criar programas complexos.</p>

<p>Para começar, todo programa de terminal como Gnome Console ou Konsole emula um dispositivo terminal “de verdade” (físico mesmo) que estava ligado ao sistema principal via rede. Nessa configuração o terminal (e seu teclado) podia estar conectado ao sistema via linha telefônica e estar a quilômetros de distância.</p>

<p>Obviamente o terminal podia exibir caracteres e receber entrada via teclado. O que não é tão óbvio é que o terminal também pode ser controlado via sequências especiais de bytes. Podemos mudar as cores do texto e do fundo, posicionar o cursor em qualquer lugar da tela e rolar todas as linhas para cima (ou para baixo). Em terminais modernos conseguimos também mostrar caracteres unicode (com acentos, orientais e/ou ícones). Ou seja, o terminal é excelente para programas que tratam texto e pode ser muito interativo. Dá até para habilitar suporte a mouse!</p>

<p>Uma outra vantagem do terminal é que os programas podem ser muito leves. As opções de layout são limitadas e a interação em geral é diferente de programas gráficos. Um exemplo clássico é a rolagem de tela: vários programas otimizam ao máximo essa operação, porém o terminal funciona em um esquema de páginas em que a maioria das rolagens de tela apagam pelo menos metade do texto. Ou seja, o que pode ser importante para conteúdos ricos em gráficos e interações via toque também pode ser irrelevante em uma aplicação que só trabalha com texto.</p>

<p>Vamos então a como controlar o terminal. Temos uma série de sequencias especiais que começam com dois caracteres de controle. Ao enviar os bytes <code class="language-plaintext highlighter-rouge">ESC</code>+<code class="language-plaintext highlighter-rouge">[</code> o terminal irá interpretar a sequência de bytes seguintes como um comando.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ESC[2J</code> limpa a tela inteira</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[L;CH</code> move o cursor para a linha L e coluna C</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[1m</code> liga o modo negrito. Todo texto a seguir será escrito em negrito</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[0m</code> reseta para o formato padrão do terminal</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[38;2;127;255;255m</code> muda a cor para RGB(127, 255, 255)
Também temos códigos de controle com 1 caracter só, que são enviados com a tecla Ctrl pressionada. Por exemplo, Ctrl+J envia um caracter de nova linha para o terminal. A Wikipedia tem uma lista não exaustiva de códigos de controle.</li>
</ul>

<p>Isso já nos permite escrever programas que mostram textos coloridos e posicionam o cursor em qualquer lugar da tela! Veja o exemplo abaixo em Gleam</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/io  
  
pub fn main() {  
 io.print("\u{1b}[10;5H \u{1b}[1m IGOR!\u{1b}[0m normal!")  
 io.print("\u{1b}[38;2;127;255;255mCOR!")  
    
}</code></pre></figure>

<p>É feio? Muito, mas podemos melhorar muito a legibilidade com funções. O exemplo abaixo é bem mais legível.</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/io  
  
fn bold(s) {  
  "\u{1b}[1m" &lt;&gt; s &lt;&gt; "\u{1b}[0m"  
}  
  
pub fn main() {    
 io.println(bold("IGOR") &lt;&gt; " normal")     
}</code></pre></figure>

<p>Um aspecto final do funcionamento do terminal é o tratamento da entrada (line discipline, em linux). A maneira padrão é o modo cooked, em que o terminal só envia os dados entrados pelo usuário após a tecla Enter ser pressionada. Também podemos habilitar o modo raw, em que toda tecla é disponibilizada instantâneamente para o programa.</p>

<blockquote>
  <p>:warning: A rigor cada modo é um conjunto de opções mais simples oferecidas pelo kernel do Linux para configurar o terminal.</p>
</blockquote>

<p>É possível usar a API posix para configurar o terminal, mas nesse momento vamos facilitar nossa vida e usar a ferramenta de comando ˋsttyˋ. Ela permite configurar todas opções do terminal e pode ser chamada em Gleam usando o pacote shellout. O exemplo abaixo mostra um programa que limpa o terminal, o coloca em modo raw, e mostra na linha 3 coluna 0 o último caractere digitado. O programa para quando digitamos q.</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/int  
import gleam/io  
import gleam/result  
import shellout  
  
@external(erlang, "io", "get_chars")  
pub fn get_chars(prompt: String, count: int) -&gt; String  
  
fn clear() {  
 io.print("\u{1b}[2J")  
}  
  
fn raw_mode_enter() {  
 shellout.command("stty", ["raw", "-echo"], ".", [])  
}  
  
fn raw_mode_end() {  
 shellout.command("stty", ["-raw", "echo"], ".", [])  
}  
  
fn move_cursor(row: Int, col: Int) {  
 io.print("\u{1b}[" &lt;&gt; int.to_string(row) &lt;&gt; ";" &lt;&gt; int.to_string(col) &lt;&gt; "H")  
}  
  
fn input_loop() {  
 let k = get_chars("", 1)  
 case k {  
   "q" -&gt; Nil  
   _ -&gt; input_loop()  
 }  
}  
  
pub fn main() {  
 clear()  
 raw_mode_enter()  
 move_cursor(3, 0)  
 input_loop()  
 raw_mode_end()  
}</code></pre></figure>

<p>Esse controle do terminal já nos dá quase tudo que precisamos para criar um editor de texto! No próximo texto falarei de arquivos e acabaremos com um “visualizador” de arquivos. Até :)</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[Eu gosto de editores de texto.Mesmo. Já testei uma porção deles e de todos os tipos, desde neovim e Emacs até os menos conhecidos como helix e micro. Também uso editores de texto GUI e já experimentei um monte deles. Aliás, minhas contribuições mais complexas no elementary linux foram justamente no editor de texto Code.]]></summary></entry><entry><title type="html">Anotações em sala de aula</title><link href="/reflexao/2024/04/25/anotacoes.html" rel="alternate" type="text/html" title="Anotações em sala de aula" /><published>2024-04-25T00:00:00-03:00</published><updated>2024-04-25T00:00:00-03:00</updated><id>/reflexao/2024/04/25/anotacoes</id><content type="html" xml:base="/reflexao/2024/04/25/anotacoes.html"><![CDATA[<style>
    img[alt=centered] {
        display:block;
        margin-left: auto;
        margin-right: auto;
        max-width: 90%;
    }
</style>

<p>Seguindo minhas reflexões do <a href="https://igordsm.github.io/reflexao/2024/03/19/escrever-a-mao.html">último texto</a>, tenho notado em minhas aulas que o número de alunos que faz anotações à mão diminuiu muito desde que comecei em 2017. Não só isso: uma parte dos alunos parece não anotar <strong>nada</strong>, confiando basicamente em sua própria memória e no material de aula.</p>

<p>Para mim anotar, especialmente à mão, faz parte do meu processo de aprendizagem. Escrever me ajuda a organizar os pensamentos e, com isso, relacionar temas e solidificar a memória. Também me ajuda a focar: escrever é um ato que mistura uma ação mecânica (desenhar as letras e/ou digitar) com uma ação intelectual (pensar no que estou fazendo). Acaba sobrando pouco espaço para distrações quando escrevo.</p>

<p>Nem sempre anotar à mão é prático e vejo que muitos alunos ignoram a existência do papel e caneta. Porém, temos diversas ferramentas digitais úteis! Apps como <a href="https://app.mural.co/">Mural</a>, <a href="https://www.canva.com/">Canva</a> e <a href="https://excalidraw.com/">Excalidraw</a> permitem criar diagramas e organizar pensamentos da mesma forma que desenhar/escrever no papel. Acho muito bons os murais que o <a href="https://github.com/rafaelcorsi">Rafael Corsi</a> monta para organizar os experimentos/papers que faz.</p>

<p><img src="/assets/excalidraw.png" alt="centered" /></p>

<p>Além disso, nas salas no Insper temos lousas nas paredes inteiras e algumas portáteis que podemos usar para rascunhar e pensar em grupo. Opções não faltam, mas parece que a ideia de ter anotações e usá-las para raciocinar simplesmente sumiu da educação que os alunos receberam antes de entrar na faculdade.</p>

<p>Encucado com isso fui pesquisar o que a ciência diz disso e encontrei artigoes interessantes. Uma busca no <a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=science+text+comprehension+&amp;btnG=">Google Scholar</a> por “science text comprehension” traz diversos estudos sobre como aprender com textos acadêmicos expositivos. E vários citam estratégias bem “tradicionais”: desenhar, imaginar o conteúdo do texto, sumarizar e explicar o texto para si mesmo. O que me marca é que é necessário <strong>intenção e ação</strong> para aprender de um texto, e que isso é uma habilidade treinável e não um traço inerente a alguns estudantes.</p>

<p>Por enquanto vou parar por aqui, mas penso em pesquisar um pouco mais sobre isso e quem sabe adicionar links e recursos sobre como ler e aprender melhor. Assim como o anterior, esse texto não tem muito fim. Quando eu conseguir organizar melhor as informações que pesquisei sobre compreensão de textos devo continuar a escrever sobre esse assunto.</p>]]></content><author><name></name></author><category term="reflexao" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Não se escreve mais à mão?</title><link href="/reflexao/2024/03/19/escrever-a-mao.html" rel="alternate" type="text/html" title="Não se escreve mais à mão?" /><published>2024-03-19T00:00:00-03:00</published><updated>2024-03-19T00:00:00-03:00</updated><id>/reflexao/2024/03/19/escrever-a-mao</id><content type="html" xml:base="/reflexao/2024/03/19/escrever-a-mao.html"><![CDATA[<style>
    img[alt=centered] {
        display:block;
        margin-left: auto;
        margin-right: auto;
        max-width: 90%;
    }
</style>

<p>Tenho visto em minhas aulas de Algoritmos que a maioria da sala tem uma certa resistência a usar papel e caneta durante as atividades de sala. Em geral fazemos muitas simulações de algoritmos, procuramos exemplos de entradas difíceis e escrevemos pseudo-código. Escrever, desenhar e rabiscar foram parte importante do meu processo de pensar e encontrar soluções para estas tarefas.</p>

<p>Acho interessante ver alguns tentando simular coisas complicadas de cabeça ou escrever pseudo-código sem ter uma entrada do lado para ir testando. Usar somente editores de texto no PC me parece bem mais limitado do que poder criar a minha própria organização dos pensamentos no papel. E não é falta de material bom: toda sala tem papel de rascunho disponível e umas lousas portáteis como as abaixo para ajudar a rascunhar e pensar em grupo.</p>

<p><img src="/assets/lousas.jpeg" alt="centered" /></p>

<p>Eu sempre tento levar uma delas comigo para discutir dúvidas e parece ajudar a concretizar os pensamentos, mas noto que a maioria não tem esse costume. Para mim escrever ajuda com os seguintes pontos:</p>

<ul>
  <li>focar em uma coisa só e evitar distrações</li>
  <li>relacionar temas distintos criando uma espécie de mapa conceitual improvidado</li>
  <li>fazer brainstorm sozinho ao ir escrevendo pensamentos rápido e sem filtrar muito</li>
  <li>quando estou ansioso ou inquieto, ajuda a organizar meus pensamentos e me centrar no que quero fazer no momento atual.</li>
</ul>

<p>Não acho um problema fazer diferente de mim, só achei intrigante que não consegui identificar qual seria o processo dos alunos para estas tarefas. Fico até pensando se não seriam um tema de pesquisa legal. Certamente já existem estudos nessa direção e vê-los aplicados à computação pode ser muito interessante para mim.</p>

<p>Enfim, esse texto não tem muita conclusão mesmo. É só uma observação do meu dia a dia… Tive a ideia de fazer isso escrevendo à mão ideias de post =)</p>]]></content><author><name></name></author><category term="reflexao" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Datas em formato Excel OpenXML usando Nim</title><link href="/code/2024/01/26/datas-excel.html" rel="alternate" type="text/html" title="Datas em formato Excel OpenXML usando Nim" /><published>2024-01-26T00:00:00-03:00</published><updated>2024-01-26T00:00:00-03:00</updated><id>/code/2024/01/26/datas-excel</id><content type="html" xml:base="/code/2024/01/26/datas-excel.html"><![CDATA[<p>Representar  dados em computadores é uma tarefa que parece fácil mas que é na verdade bem complicada. Vou falar um pouco aqui sobre uma experiência que tive trabalhando com planilhas Excel na linguagem <a href="https://nim-lang.org">Nim</a> com a biblioteca <a href="https://github.com/khchen/xl/">xl</a>.</p>

<p>Arquivos com extensão <em>.xlsx</em> estão no formato OpenXML, um padrão com especificação aberta que é basicamente um arquivo <em>zip</em> com estrutura fixa de pastas e uma porção de arquivos <em>.xml</em> dentro. Não é exatamente complicado e só de abrir e ler os nomex e conteúdos dos arquivos já daria para entender mais ou menos como as coisas funcionam.</p>

<p>Menos para datas… Datas já são um <a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">tema bem complicado</a>, então ler datas em um arquivo externo é pedir pra sofrer.</p>

<p>Examinando os valores das células, vi que a data para o dia <em>22 de dezembro de 2023</em> terá o valor …. Não ajuda muito, certo? De acordo com a documentação do formato OpenXML, datas estão no formato <em>1900-compatibility mode</em>. A explicação rápida é que o número representa dias após a data base <em>01 de janeiro de 1900</em>. Isso não batia muito com minhas contas e <a href="http://www.ericwhite.com/blog/dates-in-spreadsheetml/">esse site</a> muita coisa. No fim acabei encontrando também a <a href="https://learn.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system">documentação oficial sobre este tópico</a>, mas achei o primeiro link mais didático.</p>

<p>Para começar, a explicação rápida é enganosa. A data <em>01 de janeiro de 1900</em> tem valor <strong>1</strong>, portanto o número representa o número de dias após <em>31 de dezembro de 1899</em>. Pode ser intuitivo para não programadores, mas pra nós programadores que indexamos o primeiro elemento como 0 é bastante confuso.</p>

<p>Tem mais: infelizmente um software antigo e muito famoso na década de 80 e 90 chamado Lotus 123 criou essa representação, mas errou feio e considerou que 1900 era ano bisexto (e não é!). Assim, uma tonelada de planilhas foram criadas com a contagem de dias errada e os programas concorrentes precisavam ser capazes de ler e intrepretar esses dados. Por isso esse modo de armazenar datas é chamado <em>1900 compatibility mode</em>. É compatível com um software de 30 anos atrás que ninguém mais usa, mas que criou uma quantidade enorme de dados nesse formato e que precisam ser lidos…</p>

<p><img src="https://winworldpc.com/res/img/screenshots/2e2a25fbb4a2f9b686b7b161059cfb5f7c568c8f5d572b6382f0ebe0fb8c35c7.png" alt="" /></p>

<p>Aliás, olha só que doideira: nem os softwares de planilha mais usados (Excel, LibreOffice e OnlyOffice) concordam e e mostram datas diferentes para a mesma célula com data <em>05 de janeiro de 1900</em>. Pelo menos eles concordam quando a data passa de <em>01 de março de 1900</em>….</p>

<p><img src="/assets/datas-diferentes-excel.png" alt="" /></p>

<p>Vamos ver agora o código atual da <code class="language-plaintext highlighter-rouge">xl</code> que devolve um <code class="language-plaintext highlighter-rouge">datetime</code> a partir de uma célula com dados no formato que descrevi acima.</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">date</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">:</span> <span class="n">XlCell</span><span class="p">):</span> <span class="n">DateTime</span> <span class="o">=</span>
  <span class="sd">## Assume the number of cell is a date and return it.</span>
  <span class="sd">## Using 1900 date system: a serial number that represents the number of days</span>
  <span class="sd">## elapsed since January 1, 1900.</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">dateTime</span><span class="p">(</span><span class="mi">1900</span><span class="p">,</span> <span class="n">mJan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">+=</span> <span class="n">initDuration</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">xc</span><span class="p">.</span><span class="n">number</span> <span class="o">*</span> <span class="mi">86400</span><span class="p">))</span>
</code></pre></div></div>

<p>A intuição do código faz todo sentido: um dia tem <code class="language-plaintext highlighter-rouge">84600</code> segundos, então basta somar isso vezes o número de dias para chegar na data correta. Mas está errado :S O número de dias varia conforme a data é antes ou depois de 29 de fevereiro de 1900. Além disso,o dia 01 de janeiro de 1900 é o número sequencial <strong>1</strong>!</p>

<p>Estou tentando me envolver novamente com projetos abertos e <em>Nim</em> é uma linguagem interessante. Por isso <a href="https://github.com/khchen/xl/pull/6">enviei um PR</a> com uma correção (e testes!) e espero que seja aprovado logo. Estou usando essa lib em um projeto simples para converter planos de aula em arquivos <em>.ics</em> para colocar no meu calendário. Posto sobre isso quando estiver mais pronto.</p>]]></content><author><name></name></author><category term="code" /><summary type="html"><![CDATA[Representar dados em computadores é uma tarefa que parece fácil mas que é na verdade bem complicada. Vou falar um pouco aqui sobre uma experiência que tive trabalhando com planilhas Excel na linguagem Nim com a biblioteca xl.]]></summary></entry><entry><title type="html">Minha vida tem propagandas demais</title><link href="/2024/01/21/propagandas-demais.html" rel="alternate" type="text/html" title="Minha vida tem propagandas demais" /><published>2024-01-21T00:00:00-03:00</published><updated>2024-01-21T00:00:00-03:00</updated><id>/2024/01/21/propagandas-demais</id><content type="html" xml:base="/2024/01/21/propagandas-demais.html"><![CDATA[<p>Nesses últimos tempos a TIM tem se superado comigo: se perco uma ligação a operadora me manda um SMS dizendo que se eu tivesse o serviço “TrueCaller qualquer coisa” eu conseguiria ver o número que me ligou! Ou as infinitas ligações para me dizer que eu tenho um recado e que se quiser ouvir eu tenho que ligar para um outro número. Também já me ofereceram Créditos a Cobrar, diversos planos diferentes e novas condições imperdíveis (que eu perdi).</p>

<p><img src="https://i.ytimg.com/vi/4vADPI0D9k4/maxresdefault.jpg" alt="Propagand chata da TIM" class="capa" /></p>

<p>Eu não me lembro da última vez que recebi um SMS de alguém conhecido. Email então? Só se for de trabalho e tem ficado cada vez mais raro. Ligações também são escassas e a maioria é spam. Inclusive, quase toda comunicação que eu recebo de algum serviço que me importa ou cai em um filtro anti-spam ou é feito um pedido explícito para checar se a última mensagem importante caiu no anti-spam. Parece que cada dia mais tecnologias tecnicamente válidas são estragadas pela quantidade de anúncios e tentativas de golpe que chegam.</p>

<p>Algo interessante é que essas tecnologias tem  algumas coisas em comum:</p>

<ol>
  <li>elas são federadas, ou seja, é possível contactar pessoas conectadas em servidores/operadoras diferentes</li>
  <li>existe pouca ou nenhuma moderação de conteúdo</li>
  <li>é praticamente impossível banir alguém</li>
</ol>

<p>Isso as torna fácil de abusar e, com a abundância de propagandas e tentativas de golpe recentes, cada vez menos úteis para seus usuários. Lembra um pouco o ciclo de <a href="/livros/2023/12/17/livro-internet-con.html">enshittification do Livro de Corey Doctorow</a>, mas dessa vez não tem um ator central “estragando tudo”.</p>

<p>Esse ciclo está alcançando agora a Web: desde sites com toneladas de conteúdo de baixa qualidade (veja <a href="https://www.theregister.com/2022/12/06/internet_ai_gpt_ios/">esse estudo</a>) como BuzzFeed e WikiHow até diversos relatos de que <a href="https://arstechnica.com/gadgets/2024/01/google-search-is-losing-the-fight-with-seo-spam-study-says/">o Google está ficando pior</a>. Para mim, <a href="https://fosstodon.org/@bluesabre@floss.social/111782621233837503">esse exemplo</a> é o exemplo maior de tudo isso: a conversão de bytes para MB quebrou no Google. Algo que funcionava bem agora está bugado e não há razão clara para isso.</p>

<p>Esse post foi motivado pela minha recente decisão de desabilitar Javascript em páginas que não são aplicações web. Apesar de alguns sites pararem de funcionar corretamente, isso tornou minha experiência muito melhor em geral. Quase tudo carrega instantâneo e isso até faz alguns Paywalls pararem de funcionar. Tenho usado o <a href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/">uBlock Origin</a> e tem sido muito bom. Sinto que não perdi nada em termos de minha experiência de uso da Web e ganhei muito em termos de velocidade e praticidade.</p>

<p>Outra mudança foi me motivar a buscar outras maneiras de consumir conteúdo interessante. Tenho usado mais minha conta no <a href="https://fosstodon.org/@igordsm">Fosstodon</a>, leio alguns blogs que gosto e estou tentando ressucitar o costume de usar RSS ao invés de visitar portais de conteúdo. Talvez seja meio antiquado, mas por enquanto estou gostando.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Nesses últimos tempos a TIM tem se superado comigo: se perco uma ligação a operadora me manda um SMS dizendo que se eu tivesse o serviço “TrueCaller qualquer coisa” eu conseguiria ver o número que me ligou! Ou as infinitas ligações para me dizer que eu tenho um recado e que se quiser ouvir eu tenho que ligar para um outro número. Também já me ofereceram Créditos a Cobrar, diversos planos diferentes e novas condições imperdíveis (que eu perdi).]]></summary></entry><entry><title type="html">“Am I good enough?” - Michelle Obama</title><link href="/livros/2023/12/25/livro-michelle-obama.html" rel="alternate" type="text/html" title="“Am I good enough?” - Michelle Obama" /><published>2023-12-25T00:00:00-03:00</published><updated>2023-12-25T00:00:00-03:00</updated><id>/livros/2023/12/25/livro-michelle-obama</id><content type="html" xml:base="/livros/2023/12/25/livro-michelle-obama.html"><![CDATA[<p>Acabei de ler o livro “Minha história” da Michelle Obama e gostei bastante.</p>

<p><img src="https://m.media-amazon.com/images/I/815rLjPo9KL._AC_UF1000,1000_QL80_FMwebp_.jpg" alt="Capa do livro &quot;minha história&quot; de Michelle Obama" class="capa" /></p>

<p>O livro é uma autobiografia, então obviamente a própria Michelle conta sua história desde quando era a criança Michelle Robinson até o fim de sua estadia na casa branca como primeira dama Michelle Obama. Tudo muito bem escrito e com uma boa dose tanto de realismo quanto de humor, o livro é de leitura fácil e prende bem. São mais de 400 páginas que passam até bem rápido.</p>

<p>Dentre os muitos pontos marcantes no livro vou citar dois aqui que me fizeram pensar. O primeiro é uma frase que ela repete ao longo do livro (e da vida) para ela mesma em momentos de dificuldade: “Am I good enough? Yes, I am”. Eu gostei muito dessa frase encorajadora justamente por ela ser simples. Ela não se encoraja dizendo que é maravilhosa, linda, forte, excepcional ou qualquer adjetivo que implique grandeza e superioridade. Para ter coragem basta dizer que ela é boa <em>o suficiente</em>, nada mais nem nada menos que isso. Ler isso para mim é um alívio. Eu acho bastante arrogante eu dizer para mim mesmo que sou excelente, inteligente, trabalhador ou qualquer coisa desse tipo. Mas eu consigo dizer, sem soar artificial ou arrogante, que sou bom o suficiente para encarar um desafio ou circunstância difícil.</p>

<p>O segundo ponto é que essa mensagem de apoio é passada para outras pessoas, especialmente jovens, constantemente. De menina pobre de Chicago ela foi para Princeton e Harvard com o apoio de muita gente (citados no livro :) E decide então que não é especial, fodona e gênia, mas sim reconhece que teve esse apoio e tenta dizer para jovens desfavorecidos que ela também já esteve lá. E ouvir isso importamuito. Uma das visitas mais marcantes foi à escola Elizabeth Garret Anderson, que ensinava primariamente crianças negras ou de minorias étnicas. Foram 3 contatos (2009 ,2011 e 2012) e <a href="https://theconversation.com/how-michelle-obamas-visit-to-a-london-school-helped-boost-students-grades-61694https://theconversation.com/how-michelle-obamas-visit-to-a-london-school-helped-boost-students-grades-61694https://theconversation.com/how-michelle-obamas-visit-to-a-london-school-helped-boost-students-grades-61694">esta reportagem</a> mostra que houve um ganho de desempenho significativo das alunas a partir de 2010 nos testes padronizados. É claro que existem vários fatores que podem influenciar isso, então não é exatamente possível afirmar que essa foi a causa da melhora. Porém, é significativo que não só essa escola aparece no livro como ela voltou para lá em 2018 para reforçar a mensagem e a importância do acontecimento em sua vida.</p>

<p>Para finalizar, todas as histórias do livro acontecem em um contexto diferente do meu: quem conta a história é uma mulher negra que tenta a todo momento encontrar sua voz e ocupar um lugar no mundo de acordo com o que ela acredita. Suas buscas e dilemas são colocados de maneira tão humana que essas diferenças me aproximaram da história e me deixaram inspirado. Vale a leitura :)</p>]]></content><author><name></name></author><category term="livros" /><summary type="html"><![CDATA[Acabei de ler o livro “Minha história” da Michelle Obama e gostei bastante.]]></summary></entry><entry><title type="html">Livro “The Internet Con” (Cory Doctorow)</title><link href="/livros/2023/12/17/livro-internet-con.html" rel="alternate" type="text/html" title="Livro “The Internet Con” (Cory Doctorow)" /><published>2023-12-17T00:00:00-03:00</published><updated>2023-12-17T00:00:00-03:00</updated><id>/livros/2023/12/17/livro-internet-con</id><content type="html" xml:base="/livros/2023/12/17/livro-internet-con.html"><![CDATA[<style>
    img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        max-width: 90%;
        max-height: 300px
    }
</style>

<p>Recentemente acabei de ler o livro <a href="https://www.versobooks.com/en-gb/products/3035-the-internet-con">“The Internet Con: how to seize the means of computation”</a> por Cory Doctorow.</p>

<p><img src="https://www.versobooks.com/cdn/shop/files/getimage_f56a5b40-cc2c-496e-a798-9da52c436081.jpg?v=1690862906&amp;width=584" alt="" /></p>

<p>O tema principal do livro é uma estratégia de negócios comumente usada nas principais Big Techs atualmente: criação de um produto baseado no <em>Efeito de Rede</em> e posterior aumento do <em>Custo de troca</em> para que os usuários continuem na plataforma mesmo após ela não ser tão vantajosa quanto no início.</p>

<p><em>Efeito de rede</em> é o nome dado a uma caracterísitca bem interessante de vários serviços online: quanto mais gente que você conhece usa maior é o valor que o serviço retorna a você. Note que a relação aqui é simétrica e até um tanto simbiótica: o fato de você usar também cria incentivos e benefícios para que os seus conhecidos usem (ou continuem usando) o serviço. Esse efeito não é negativo isoladamente, mas se torna complexo quando é aplicado em plataformas fechadas.</p>

<p>Isso nos leva ao segundo ponto do livro: <em>Custo de troca</em>. Ao fecharem cada vez mais suas plataformas e não permitirem interoperabilidade ou acessos via API essas plataformas aumentam o <em>Custo de trocar para um concorrente</em>. Aliado ao <em>Efeito de rede</em>, isso cria um ambiente não competitivo em que seria necessário levar grande parte dos seus contatos para o novo concorrente para continuar tendo os mesmos benefícios.</p>

<p>Segundo o autor, essa mistura leva a uma queda na utilidade dos serviços prestados: agora que os usuários estão presos na plataforma pode-se fazer o que quiser para aumentar seus lucros. Seria por isso que “todo mundo odeia Facebook/twitter mas não consegue parar de usar”. O principal argumento é que isso cria estruturas de poder com influência e dinheiro grandes demais para serem saudáveis para a sociedade (segundo o autor).</p>

<p>A solução proposta pela autor é a interoperabilidade dessas plataformas, mesmo que forçada por legislação ou via engenharia reversa. Os exemplos citados incluem reparos de telefones e até tratores, mas passam também por coisas mais cotidianas como programas de mensagens e redes sociais. A ideia geral é que toda a tecnologia que temos e usamos deveria ser acessível para reparos e usos sem restrições artificais de disponibilidade e/ou concorrência.</p>

<p>Algumas notícias recentes como a <a href="https://www.theverge.com/2023/12/13/24000120/threads-meta-activitypub-test-mastodon">adoção de ActivityPub pelo Threads</a> ou da interop forçada do iMessage<a href="https://www.engadget.com/apple-confirms-it-has-blocked-imessage-exploit-012015485.html">[1]</a><a href="https://www.engadget.com/beeper-mini-is-back-promising-imessage-access-on-android-if-you-sign-in-with-an-apple-id-182924774.html">[2]</a> tornaram o livro mais relevante para mim. Gosto de tecnologias não tradicionais, então sempre comemoro quando esse tipo de movimento ocorre. Enfim, recomendo a leitura. Dá para ler fácil em um fim de semana e serve como introdução a vários assuntos legais de Web aberta e tecnologias alternativas.</p>]]></content><author><name></name></author><category term="livros" /><summary type="html"><![CDATA[]]></summary></entry></feed>