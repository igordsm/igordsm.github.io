<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-07-23T17:34:44-03:00</updated><id>/feed.xml</id><title type="html">Igor Montagner</title><subtitle>Igor&apos;s personal and academic website. </subtitle><entry><title type="html">Criando um editor de texto - parte 5</title><link href="/editor-de-texto/2024/07/23/editor-de-texto-5.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 5" /><published>2024-07-23T00:00:00-03:00</published><updated>2024-07-23T00:00:00-03:00</updated><id>/editor-de-texto/2024/07/23/editor-de-texto-5</id><content type="html" xml:base="/editor-de-texto/2024/07/23/editor-de-texto-5.html"><![CDATA[<p>O visualizador já está pronto, agora é começar a editar! Vamos então começar a editar texto e nosso primeiro exemplo será bem simples: editar uma única linha, incluindo usar as setas para esquerda e direita para posicionar o cursor. O resultado fica parecido com o abaixo.</p>

<video controls="" width="80%">
<source src="/assets/editor-de-texto/part5.mkv" type="video/mp4" />
</video>

<p>Nosso primeiro passo será definir um tipo <code class="language-plaintext highlighter-rouge">EditableString</code>. Isso é necessário pois modificar uma String acarreta na criação de uma nova String. Por isso iremos tratar nosso texto como uma lista de <a href="https://pt.wikipedia.org/wiki/Grafema">grafemas</a>. Outro ponto: saber o tamanho da nossa string é importante, por isso iremos guardar esse valor no nosso tipo. O algoritmo <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#length">list.length</a> em Gleam é $\mathcal{O}(n)$, então seria legal evitar passar pela lista inteira só para pegar seu tamanho.</p>

<pre><code class="language-gleam">pub type EditableString {
  EditableString(text: List(String), total_length: Int)
}

pub fn new() {
  EditableString([], 0)
}
</code></pre>

<p>A partir desse texto iremos tentar aproveitar melhor as funções da biblioteca padrão de Gleam e escrever código que aproveite o módulo <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html">list</a>. Vejamos um exemplo simples que mostra nossa string no terminal.</p>

<pre><code class="language-gleam">pub fn print(es: EditableString) {
  list.each(es.text, io.print)
}
</code></pre>

<p>A função <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#each">list.each</a> aplica uma função a cada elemento do primeiro argumento e descarta o resultado. Isso é perfeito para o nosso caso, em que queremos chamar a mesma função para todo elemento da lista. Daria para fazer com a recursão que já usamos em outros textos, mas fica bem mais comprido…</p>

<pre><code class="language-gleam">pub fn print(es: EditableString) {
  [] -&gt; Nil
  [first, ..rest] -&gt; {
    io.print(first)
    print(rest)
  }
}
</code></pre>

<p>A inserção também pode ser feita com funções de <code class="language-plaintext highlighter-rouge">list</code> e fica bem curtinha :) As funções <code class="language-plaintext highlighter-rouge">take</code> e <code class="language-plaintext highlighter-rouge">drop</code> são relativamente explicativas, então vou focar no <code class="language-plaintext highlighter-rouge">flatten</code>. Ele pega uma lista de listas e transforma em uma lista com um nível só. Super útil no caso abaixo, que ficamos com uma lista com três pedaços do texto.</p>

<pre><code class="language-gleam">pub fn insert_at_cursor(es: EditableString, pos, str) {
  let sl = es.text
  let new_list =
    [list.take(sl, pos), string.to_graphemes(str), list.drop(sl, pos)]
    |&gt; list.flatten
  EditableString(new_list, es.total_length + string.length(str))
}
</code></pre>

<p>A etapa final é criar o loop de eventos e garantir que o cursor aponta para o lugar certo. Veja abaixo.</p>

<pre><code class="language-gleam">fn input_loop(es: EditableString, cursor: Int) {
  case terminal.get_key() {
    terminal.CursorMovement(terminal.LEFT) -&gt; {
      let new_cursor = int.max(cursor - 1, 1)
      terminal.move_cursor(0, new_cursor)
      input_loop(es, new_cursor)
    }
    terminal.CursorMovement(terminal.RIGHT) -&gt; {
      let new_cursor = int.min(es.total_length + 1, cursor + 1)
      terminal.move_cursor(0, new_cursor)
      input_loop(es, new_cursor)
    }
    terminal.Letter(s) -&gt; {
      terminal.clear_line()
      let new_es = editable_string.insert_at_cursor(es, cursor - 1, s)
      terminal.move_cursor(0, 1)
      editable_string.print(new_es)
      terminal.move_cursor(0, cursor + 1)
      input_loop(new_es, cursor + 1)
    }
    terminal.Enter -&gt; Nil
    terminal.UNKNOWN -&gt; Nil
    _ -&gt; Nil
  }
}
</code></pre>

<p>Apertar <code class="language-plaintext highlighter-rouge">Enter</code> finaliza a edição da linha. Esse código ainda tem alguns problemas:</p>

<ol>
  <li>se a linha ficar maior que o terminal o cursor vai ficar piscando no fim da linha 1, porém o texto vai ser editado no lugar correto.</li>
  <li>o cursor fica sempre na primeira linha.</li>
  <li>não há nenhum tratamento para o número de linhas no terminal que o texto ocupa.</li>
</ol>

<p>Porém, já temos um grande avanço em termos de interação. Juntar isso com o visualizador ainda vai dar trabalho e isso fica pros próximos textos :P</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[O visualizador já está pronto, agora é começar a editar! Vamos então começar a editar texto e nosso primeiro exemplo será bem simples: editar uma única linha, incluindo usar as setas para esquerda e direita para posicionar o cursor. O resultado fica parecido com o abaixo.]]></summary></entry><entry><title type="html">Escolhas individuais importam?</title><link href="/reflexao/2024/07/04/escolhas-individuais-importam.html" rel="alternate" type="text/html" title="Escolhas individuais importam?" /><published>2024-07-04T00:00:00-03:00</published><updated>2024-07-04T00:00:00-03:00</updated><id>/reflexao/2024/07/04/escolhas-individuais-importam</id><content type="html" xml:base="/reflexao/2024/07/04/escolhas-individuais-importam.html"><![CDATA[<p>A tragédia no Rio Grande do Sul me fez pensar em várias questões mais abrangentes e uma delas foi uso de energia e emissões de carbono. Um discurso muito comum e “empoderador” é o de cada um fazer sua parte e que isso vai criar um efeito bola de neve e ter impacto grande na sociedade. Coisas do tipo deixar de usar canudos plásticos, cobrar por sacolas no supermercado ou usar copos de papel.</p>

<p>É tudo muito bonito, mas não encontro as evidências de que isso adiante… Por exemplo, <a href="https://g1.globo.com/meio-ambiente/noticia/2023/08/25/canudos-de-papel-ou-bambu-podem-nao-ser-tao-sustentaveis-quanto-se-pensava-diz-estudo-entenda.ghtml">canudos de papel tem também um montede químicos “eternos”</a>. Também existe o fato de que <a href="https://veja.abril.com.br/coluna/radar-economico/qual-o-real-desperdicio-de-agua-por-parte-da-sabesp/">a SABESP desperdiça uns 30% da água portável distribuída por conta dos vazamentos da tubulação</a> . Quem sabe vale lembrar do <a href="https://www.infomoney.com.br/consumo/prejuizo-bilionario-quem-vai-pagar-a-conta-da-falta-de-luz-no-centro-de-sp/">apagão de cinco dias no centro de SP que deu um baita prejuízo ao comércio local</a>. Nada disso depende de decisões individuais e de “fazer sua parte”.</p>

<p>A mais recente notícia que me lembrou desse tema foi que o <a href="....">Google aumentou suas emissões de carbono em 50% em relação ao ano passado</a>. Uma única empresa tem sozinha um impacto que <strong>milhões de indivíduos individualmente não conseguem ter, ou nesse caso compensar</strong>. A geração de uma única imagem em um sistema como Midjourney <a href="https://www.theverge.com/24066646/ai-electricity-energy-watts-generative-consumption">pode gastar a mesma quantidade de energia necessária para carregar por completo um celular</a>.</p>

<p>Todas essas notícias me trazem um grande desânimo. A sensação é de que não importa fazer boas escolhas individuais, já que os que mais podem ter impacto não tomam atitudes condizentes… Imagine só: podemos pedir a colaboração de <strong>todos</strong> habitantes de São Paulo para diminuir o uso de água em um ano de poucas chuvas. Ou a SABESP poderia consertar esses desperdícios e melhorar o uso de água em todos os anos. A notícia que eu linkei acima é de 2024, porém encontrei <a href="https://g1.globo.com/sao-paulo/noticia/sabesp-desperdica-30-da-agua-tratada.ghtml">essa de 2016</a> que cita números de desperdício muito parecidos.</p>

<p>Enfim, acho que fica aqui uma reflexão a respeito do tema. Não tenho nenhum grande insight sobre esse dilema, exceto que me parece claro que simplesmente cada um “fazer a sua parte” não é nem suficiente nem sustentável. Não é suficiente do ponto de vista do impacto gerado por essas atitudes individuais. Não é sustentável pois exige sacrifícios e ações “contra corrente” de indivíduos que não são os principais agentes de mudança.</p>]]></content><author><name></name></author><category term="reflexao" /><summary type="html"><![CDATA[A tragédia no Rio Grande do Sul me fez pensar em várias questões mais abrangentes e uma delas foi uso de energia e emissões de carbono. Um discurso muito comum e “empoderador” é o de cada um fazer sua parte e que isso vai criar um efeito bola de neve e ter impacto grande na sociedade. Coisas do tipo deixar de usar canudos plásticos, cobrar por sacolas no supermercado ou usar copos de papel.]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 4</title><link href="/editor-de-texto/2024/06/20/editor-de-texto-4.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 4" /><published>2024-06-20T00:00:00-03:00</published><updated>2024-06-20T00:00:00-03:00</updated><id>/editor-de-texto/2024/06/20/editor-de-texto-4</id><content type="html" xml:base="/editor-de-texto/2024/06/20/editor-de-texto-4.html"><![CDATA[<p>Vamos partir para uma etapa de organização de código agora que já temos um visualizador de arquivos que funciona. No final deste texto teremos algo como o gif abaixo.</p>

<video controls="" width="80%">
<source src="/assets/editor-de-texto/part4.mkv" type="video/mp4" />
</video>

<p>Os primeiros passos são melhorar nosso tipo <code class="language-plaintext highlighter-rouge">TermState</code>. Vamos colocar um pouco mais de informações nele e criar uma função <code class="language-plaintext highlighter-rouge">new</code> que cria um <code class="language-plaintext highlighter-rouge">TermState</code> a partir do conteúdo de um arquivo.</p>

<pre><code class="language-gleam">pub type TermState {
  TermState(
    fname: String,
    nlines: Int, 
    ncols: Int,
    before: queue.Queue(String),
    screen: queue.Queue(String),
    after: queue.Queue(String),
  )
}

pub fn new(fname: String, lines: String, nrows: Int, ncols: Int) -&gt; TermState {
  let line_list = split_line_max_length(lines, ncols)
  TermState(
    fname, nrows, ncols,
    queue.new(),
    queue.from_list(list.take(line_list, nrows)),
    queue.from_list(list.drop(line_list, nrows)),
  )
}
</code></pre>

<p>Isso já simplifica um bocado o código do <code class="language-plaintext highlighter-rouge">main</code>, além de facilitar futuras implementações relacionadas à edição de arquivos.</p>

<p>O outro passo é extrair o código das funções de rolagem da tela. Veja abaixo como ficaria o <code class="language-plaintext highlighter-rouge">scroll_down</code>.</p>

<pre><code class="language-gleam">pub fn scroll_down(st: TermState) {
  case queue.pop_front(st.after) {
    Ok(#(line_show, new_after)) -&gt; {
      let assert Ok(#(line_hide, new_screen)) = queue.pop_front(st.screen)
      Ok(#(
        line_show,
        line_hide,
        TermState(
          ..st,
          before: queue.push_back(st.before, line_hide),
          screen: queue.push_back(new_screen, line_show),
          after: new_after,
        ),
      ))
    }
    _ -&gt; {
      Error(st)
    }
  }
}
</code></pre>

<p>Essa função usa o tipo <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html">gleam/result</a>, que representa uma operação que pode (ou não) dar erro. No nosso caso <code class="language-plaintext highlighter-rouge">scroll_down</code> dá erro quando chegamos no fim do arquivo (<code class="language-plaintext highlighter-rouge">state.after</code> está vazio).</p>

<p>O código que recebe a tecla seta para baixo também fica um pouco mais claro.</p>

<pre><code class="language-gleam">terminal.CursorMovement(terminal.DOWN) -&gt; {
  case term_state.scroll_down(state) {
	Ok(#(line_show, line_hide, new_state)) -&gt; {
	 // atualiza interface do terminal
	 io.print("\u{1b}[1S")
	 terminal.move_cursor(state.nlines,0)
	 terminal.clear_line()
	 io.print(line_show)

	 // veremos isso mais para a frente hoje :)
	 repaint_bottom_bar(new_state, new_state.fname)
	 
	 input_loop(new_state)
	}
	Error(st) -&gt; {
	 input_loop(st)
	}
  }
  
}
</code></pre>

<p>A parte final que faremos por hoje é pintar a linha verde na parte de baixo do console. A ideia é mostrar o nome do arquivo aberto e possívelmente outras informações úteis no futuro. A sacada para fazer isso é, basicamente, criar um <code class="language-plaintext highlighter-rouge">TermState</code> com uma linha a menos do que o disponível no terminal :)</p>

<pre><code class="language-gleam">// no main
let st = term_state.new(filename, contents, nlines-1, ncols)

// e chamar a função abaixo sempre que rolar a tela
fn repaint_bottom_bar(state: TermState, fname) {
  terminal.move_cursor(state.nlines+1, 0)
  
  io.print("\u{1b}[48:5:2m")
  terminal.clear_line()
  io.print(" &lt;gled&gt; -- " &lt;&gt; fname &lt;&gt; " \u{1b}[0m")
}
</code></pre>
<p>O efeito é o do vídeo acima: uma barra verde fixa na parte de baixo do editor.</p>

<p>E é isso :) Temos agora um código um pouco (bem pouco) mais organizado antes de fazer a primeira parte difícil do editor: posicionar o cursor na tela e manter a informação de qual linha/coluna isso está mapeado no texto. O código final pode ser visto <a href="https://github.com/igordsm/term_editor/tree/main/src/part4">no repo term_editor</a>.</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[Vamos partir para uma etapa de organização de código agora que já temos um visualizador de arquivos que funciona. No final deste texto teremos algo como o gif abaixo.]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 3</title><link href="/editor-de-texto/2024/06/15/editor-de-texto-3.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 3" /><published>2024-06-15T00:00:00-03:00</published><updated>2024-06-15T00:00:00-03:00</updated><id>/editor-de-texto/2024/06/15/editor-de-texto-3</id><content type="html" xml:base="/editor-de-texto/2024/06/15/editor-de-texto-3.html"><![CDATA[<p>Agora chegamos na parte interessante que vai juntar novidades tanto de terminal (como dispositivo de hardware) quanto programação funcional. Vejamos:</p>

<ol>
  <li>gleam não tem estado. Ou seja, vai ser necessário guardar quais linhas estão na tela e quais estão fora <strong>sem modificar nenhuma variável</strong>. Além disso, precisamos persistir essas modificações enquanto o usuário interage com o programa.</li>
  <li>até agora só enviamos comandos para o terminal (via escape codes escritos na saída padrão). Agora vamos <strong>receber</strong> esses comandos também via entrada padrão.</li>
</ol>

<p>Vamos tratar um problema de cada vez, começando com como guardar o estado do nosso editor.</p>

<h2 id="representando-o-estado-atual-do-editor">Representando o estado atual do editor</h2>

<p>A primeira parte é guardar quais linhas estão dentro e fora da tela. A imagem abaixo ajuda a entender um pouco a dinâmica de um programa que mostra um arquivo no terminal.</p>

<p><img src="/assets/editor-de-texto/linhas-tela.png" alt="Ilustração de um arquivo sendo mostrado no terminal" /></p>

<p>Logo, precisamos não só de uma lista de linhas, mas de 3:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">before</code> guarda as linhas que estão <strong>antes</strong> do trecho atualmente mostrado na tela. É vazio se a primeira linha está sendo mostrada ou se o arquivo for menor que o número de linhas do terminal</li>
  <li><code class="language-plaintext highlighter-rouge">screen</code> guarda as linhas que estão sendo mostradas na tela <strong>neste momento</strong></li>
  <li><code class="language-plaintext highlighter-rouge">after</code> guarda as linhas que estão <strong>depois</strong> do trecho mostrado na tela atualmente. É vazio se a última linha está sendo mostrada ou se o arquivo for menor que o número de linhas do terminal</li>
</ul>

<p>Uma vantagem dessa representação é que rolar a tela é muito fácil!</p>

<ul>
  <li>para descer a tela precisamos transferir a última linha de <code class="language-plaintext highlighter-rouge">screen</code> para o início de <code class="language-plaintext highlighter-rouge">after</code> e transferir a última de <code class="language-plaintext highlighter-rouge">before</code> para o início de <code class="language-plaintext highlighter-rouge">screen</code>.</li>
  <li>para subir a tela precisamos transferir a primeira linha de <code class="language-plaintext highlighter-rouge">screen</code> para o fim de <code class="language-plaintext highlighter-rouge">before</code> e transferir a primeira de <code class="language-plaintext highlighter-rouge">after</code> para o fim de <code class="language-plaintext highlighter-rouge">screen</code>.</li>
</ul>

<p><em>gleam</em> possui o tipo <a href="https://hexdocs.pm/gleam_stdlib/gleam/queue.html">queue</a>, que permite adicionar/remover elementos de maneira eficiente no início e fim da coleção de dados. Portanto, o estado do nosso programa será uma tripla com esses três elementos.</p>

<pre><code class="language-gleam">type TermState {
  TermState(
    before: queue.Queue(String),
    screen: queue.Queue(String),
    after: queue.Queue(String),
  )
}
</code></pre>

<p>Esse estado agora será passado para a função <code class="language-plaintext highlighter-rouge">input_loop</code> e pode ser modificado pela entrada do usuário. Iniciamos o loop principal como mostrado abaixo:</p>

<pre><code class="language-gleam">let st =
TermState(
  queue.new(),
  queue.from_list(list.take(contents_split_lines, nlines)),
  queue.from_list(list.drop(contents_split_lines, nlines)),
)
terminal.move_cursor(0, 0)

terminal.raw_mode_enter()
input_loop(st)
terminal.raw_mode_end()
</code></pre>

<p>Rolar a tela para baixo pode ser implementado, portanto, com o código abaixo.</p>

<pre><code class="language-gleam">case queue.pop_back(state.before) {
	Ok(#(line_show, new_before)) -&gt; {
	  io.print("\u{1b}[1T") // escape code para o terminal rolar para baixo
	  terminal.move_cursor(0, 0)
	  io.print(line_show)
	  let assert Ok(#(line_hide, new_screen)) = queue.pop_back(state.screen)
	  input_loop(TermState(
		new_before,
		queue.push_front(new_screen, line_show),
		queue.push_front(state.after, line_hide),
	  ))
	}
	_ -&gt; input_loop(state)
</code></pre>

<h2 id="recebendo-teclas-não-alfanuméricas">Recebendo teclas não alfanuméricas</h2>

<p>Agora que já podemos rolar a tela precisamos ler as setinhas do teclado e completar a funcionalidade que precisamos implementar. Felizmente essa é uma tarefa fácil.</p>

<p>Os mesmos códigos que enviamos para o terminal podem ser recebidos dependendo das teclas pressionadas. Os que nos interessam são os seguintes:</p>

<p>| Tecla          | Escape Code |
| ————– | ———– |
| CURSOR UP      | <code class="language-plaintext highlighter-rouge">ESC [ A</code>   |
| CURSOR DOWN    | <code class="language-plaintext highlighter-rouge">ESC [ B</code>   |
| CURSOR FORWARD | <code class="language-plaintext highlighter-rouge">ESC [ C</code>   |
| CURSOR BACK    | <code class="language-plaintext highlighter-rouge">ESC [ D</code>   |
Podemos fazer isso mudando a função <code class="language-plaintext highlighter-rouge">get_key</code> que construímos anteriormente. Agora ele pode retornar ou uma letra (tipo <code class="language-plaintext highlighter-rouge">String</code>) ou um comando para mover o cursor. Conseguimos representar isso com os seguintes tipos em <em>gleam</em>. Note que incluímos a possibilidade <code class="language-plaintext highlighter-rouge">UNKNOWN</code> para caso algum comando não suportado (ainda) seja enviado pelo terminal.</p>

<pre><code class="language-gleam">pub type CursorDirection {
  UP
  DOWN
  LEFT
  RIGHT
}

pub type Key {
  Letter(char: String)
  CursorMovement(dir: CursorDirection)
  UNKNOWN
}
</code></pre>

<p>Nossa função <code class="language-plaintext highlighter-rouge">get_key</code> muda para a seguinte. Agora ela devolve o tipo <code class="language-plaintext highlighter-rouge">Key</code> e checa se o caractere lido é um <code class="language-plaintext highlighter-rouge">ESC</code>. Se, for chama a função <code class="language-plaintext highlighter-rouge">read_escape_sequence</code> que faz a leitura do restante do escape code. Se não só devolve o caractere lido com o construtor <code class="language-plaintext highlighter-rouge">Letter</code>.</p>

<pre><code class="language-gleam">pub fn get_key() -&gt; Key {
  case get_chars("", 1) {
    "\u{1b}" -&gt; read_escape_sequence()
  	letter -&gt; Letter(letter)
  }
}

fn read_escape_sequence() {
	get_chars("", 1) // read [
	case get_chars("", 1) {
		"A" -&gt; CursorMovement(UP)
		"B" -&gt; CursorMovement(DOWN)
		"C" -&gt; CursorMovement(RIGHT)
		"D" -&gt; CursorMovement(LEFT)
		_ -&gt; UNKNOWN
	}
}
</code></pre>

<h2 id="juntando-tudo">Juntando tudo</h2>

<p>Para juntar tudo basta mexer em <code class="language-plaintext highlighter-rouge">input_loop</code> para que o estado seja passado sempre na função recursiva e que chequemos as setas além de letras. Veja abaixo uma parte dessa função.</p>

<p>Um ponto interessante é que se não há nenhuma alteração no estado do programa basta fazer a chamada recursiva com o mesmo estado que foi recebido. É tudo bem claro e não há mudanças “escondidas”.</p>

<pre><code class="language-gleam">fn input_loop(state: TermState) {
  case terminal.get_key() {
    terminal.CursorMovement(terminal.UP) -&gt; {
      case queue.pop_back(state.before) {
        Ok(#(line_show, new_before)) -&gt; {
          io.print("\u{1b}[1T")
          terminal.move_cursor(0, 0)
          io.print(line_show)
          let assert Ok(#(line_hide, new_screen)) = queue.pop_back(state.screen)
          input_loop(TermState(
            new_before,
            queue.push_front(new_screen, line_show),
            queue.push_front(state.after, line_hide),
          ))
        }
        _ -&gt; input_loop(state)
      }
    }
	// checar seta para baixo
	terminal.Letter("q") -&gt; Nil
    _ -&gt; input_loop(state)
}
</code></pre>

<p>Um passo interessante aqui seria reorganizar esse código em módulos para podermos deixar o código mais legível e organizado. Iremos fazer isso na próxima parte, já que precisaremos extender o estado do editor para incluir posição do cursor.</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[Agora chegamos na parte interessante que vai juntar novidades tanto de terminal (como dispositivo de hardware) quanto programação funcional. Vejamos:]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 2</title><link href="/editor-de-texto/2024/06/01/editor-de-texto-2.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 2" /><published>2024-06-01T00:00:00-03:00</published><updated>2024-06-01T00:00:00-03:00</updated><id>/editor-de-texto/2024/06/01/editor-de-texto-2</id><content type="html" xml:base="/editor-de-texto/2024/06/01/editor-de-texto-2.html"><![CDATA[<p>O próximo passo da série de editor de texto em linha de comando é receber argumentos na linha de comando e abrir arquivos. Vamos já preparar o terreno também para</p>

<p>Receber argumentos é bem simples. O pacote <a href="https://hexdocs.pm/argv/">argv</a> faz isso e usar com <em>pattern matching</em> faz o código ficar bem legível. Veja abaixo a nova função <code class="language-plaintext highlighter-rouge">main</code>.</p>

<pre><code class="language-gleam">pub fn main() {
  case argv.load().arguments {
    [filename] -&gt; start_editor(filename)
    _ -&gt; io.println("Usage: file_viewer filename")
  }
</code></pre>

<p>A função <code class="language-plaintext highlighter-rouge">start_editor</code> faz a leitura do arquivo passado na linha de comando e o mostra na saída. Também bem simples, cortesia do pacote <a href="https://hexdocs.pm/simplifile/">simplifile</a> :) Um novidade aqui é o módulo <code class="language-plaintext highlighter-rouge">terminal</code>. Colocamos as funções desenvolvidas na parte anterior nesse arquivo para ficar mais organizado.</p>

<pre><code class="language-gleam">fn start_editor(filename) {
  let assert Ok(contents) = simplifile.read(filename)

  terminal.clear()
  io.print(contents)
  terminal.move_cursor(0, 0)
  terminal.raw_mode_enter()
  input_loop()
  terminal.raw_mode_end()
  Nil
}
</code></pre>

<p>Isso já faz algo bem básico: mostra um arquivo na saída do terminal e espera pela tecla <code class="language-plaintext highlighter-rouge">Q</code> para terminar o programa. Porém, se o arquivo for maior que o tamanho do terminal a tela rola e não conseguimos ver o começo! O terminal automaticamente quebra linhas quando enviamos dados, porém ao criar um editor queremos controlar essas quebras.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">stty</code> também devolve o tamanho do terminal. Então podemos adicionar a função <code class="language-plaintext highlighter-rouge">get_size</code> abaixo em <code class="language-plaintext highlighter-rouge">terminal.gleam</code> para capturar o tamanho atual do terminal. O comando <code class="language-plaintext highlighter-rouge">let assert</code> usa <em>pattern matching</em> e dá erro se o padrão não bater. É uma maneira meio feia de se tratar o erro, mas deixa bem claro que <strong>se falhar o programa vai crashar</strong>.</p>

<pre><code class="language-gleam">pub fn get_size() {
  let assert Ok(output) = shellout.command("stty", ["size"], ".", [])
  let assert Ok(#(lines, cols)) = string.split_once(output, " ")

  let assert Ok(lines) = int.base_parse(lines, 10)
  let assert Ok(cols) = int.base_parse(string.trim(cols), 10)

  #(lines, cols)
}
</code></pre>

<p>Agora o desafio vai ser transformar a string <code class="language-plaintext highlighter-rouge">contents</code> (com o conteúdo do arquivo) em uma lista de strings em que cada uma tenha no máximo a largura atual do terminal. Isso nos ajuda a contar quantas linhas vão ser efetivamente usadas quando mostrarmos o arquivo.</p>

<p>O pacote <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html">gleam/string</a> já tem uma função <code class="language-plaintext highlighter-rouge">split</code>, então o trabalho maior será processar cada linha do arquivo e, se necessário, criar uma nova lista com um ou mais “linhas virtuais” para aquela linha do arquivo. Veja um exemplo abaixo em que o tamanho máximo seria 5.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrada
["abcdefgh", "abc"]
Saída
["abcde", "fgh", "abc"]
</code></pre></div></div>

<p>Esse algoritmo vai ficar bem diferente por estarmos escrevendo em uma linguagem funcional. Pra começar <em>Gleam</em> não tem loops, é tudo recursivo. Além disso todas variáveis são imutáveis, então não dá para simplesmente adicionar ou remover elementos de uma lista. É necessário <em>criar uma nova lista sem/com o elemento</em>! Apesar de isso parecer tornar o código muito mais complicado, eu vou argumentar que na verdade ele fica mais simples. Sim, isso mesmo. Vem comigo.</p>

<p>Vamos dividir o algoritmo de criar as “linhas virtuais” em 3 casos:</p>

<ol>
  <li>a lista de linhas está vazia. Devolva então uma lista vazia.</li>
  <li>o primeiro elemento tem tamanho menor que o máximo <code class="language-plaintext highlighter-rouge">M</code>. Crie uma nova lista com o primeiro elemento intacto e chame recursivo no resto da lista.</li>
  <li>o primeiro elemento tem tamanho maior que o máximo <code class="language-plaintext highlighter-rouge">M</code>. Crie uma nova lista com três “pedaços”:</li>
  <li>os primeiros <code class="language-plaintext highlighter-rouge">M</code> elementos do atual</li>
  <li>chame recursivo em uma nova lista com o restante do elemento atual mais o restante da lista original.</li>
</ol>

<p>Pronto. Só isso! Veja agora o algoritmo <code class="language-plaintext highlighter-rouge">split_long_lines</code> escrito em <em>Gleam</em></p>

<pre><code class="language-gleam">fn split_long_lines(line_list, max_length) {
  case line_list {
    [] -&gt; []
    [current, ..rest] -&gt; {
      let curr_length = string.length(current)
      case curr_length {
        l if l &lt; max_length -&gt; [current, ..split_long_lines(rest, max_length)]
        l -&gt; {
          [string.slice(current, 0, max_length), ..split_long_lines([string.drop_left(current, max_length), ..rest], max_length)]
        }
      }
    }
  }
}
</code></pre>

<p>A descrição em código é basicamente igual ao código :D Três casos, cada um retornando uma nova lista. Só é realmente feito algo quando a linha atual é maior que o tamanho máximo.</p>

<p>Isso já praticamente resolve nosso problema! Com as linhas agora com tamanho máximo na largura do terminal, podemos só chamar <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#take"><code class="language-plaintext highlighter-rouge">list.take</code></a> e pegar as primeiras <code class="language-plaintext highlighter-rouge">nlines</code>.  Veja o resultado final abaixo.</p>

<pre><code class="language-gleam">fn start_editor(filename) {
  let assert Ok(contents) = simplifile.read(filename)
  let #(nlines, ncols) = terminal.get_size()
  let contents_split_lines = split_line_max_length(contents, ncols)

  terminal.clear()
  io.print(string.join(list.take(contents_split_lines, nlines), "\n"))
  terminal.move_cursor(0, 0)

  terminal.raw_mode_enter()
  input_loop()
  terminal.raw_mode_end()
  Nil
}
</code></pre>

<p>Agora são mostradas as primeiras linhas do arquivo até encher o terminal. O próximo passo é agora ler as setinhas do terminal e reagir, mostrando mais linhas no topo ou na parte de baixo da tela. Vamos fazer isso no próximo texto, já que precisaremos guardar o <strong>estado</strong> (trecho do arquivo sendo mostrado) do programa durante sua execução. E como só temos variáveis constantes, vai ser necessário pensar um pouco mais sobre a organização do nosso programa. Até mais.</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[O próximo passo da série de editor de texto em linha de comando é receber argumentos na linha de comando e abrir arquivos. Vamos já preparar o terreno também para]]></summary></entry><entry><title type="html">Eu quero apoiar projetos de código aberto</title><link href="/open-source/2024/05/31/apoio-codigo-aberto.html" rel="alternate" type="text/html" title="Eu quero apoiar projetos de código aberto" /><published>2024-05-31T00:00:00-03:00</published><updated>2024-05-31T00:00:00-03:00</updated><id>/open-source/2024/05/31/apoio-codigo-aberto</id><content type="html" xml:base="/open-source/2024/05/31/apoio-codigo-aberto.html"><![CDATA[<p>Há algum tempo parei de pagar o Dropbox Plus, mas ainda não vejo problema nenhum de usar Netflix, Crunchyroll, Amazon Prime e etc. Esses serviços são oferecidos por grandes empresas e baseados primariamente em software fechado. Em compensação, mal pago um tostão para os desenvolvedores de softwares que uso há anos, como Fedora, Ubuntu, Krita, Inkscape e Firefox. Sem falar em outros mais recentes que admiro, como Gleam, UBPorts e Nextcloud.</p>

<p>Tenho pensado sobre isso após ler alguns posts sobre degoogling no <a href="https://fostodon.org">fosstodon</a>… Esses e muitos outros projetos precisam de mais recursos para continuarem existindo e melhorando, porém hoje eu não contribuo financeiramente para isso. Não faz nenhum sentido eu pagar anos de Dropbox e não contribuir nada para Nextcloud, por exemplo.</p>

<p>É verdade que já fiz uma porção de contribuições a projetos abertos, porém não é a mesma coisa. Um PR aceito é uma melhoria que a comunidade recebe, mas ainda assim é necessário que um mantenedor do projeto revise, aceite e mantenha esse código funcionando ao longo do tempo. E esse mantenedor não tem o meu apoio. Ele tem até mais trabalho, já que precisa gerenciar as contribuições externas e revisar código. E essas duas coisas são bem menos interessantes que escrever código novo e implementar novas funcionalidades.</p>

<p>Por isso, decidi começar a apoiar os projetos que mais uso nos últimos tempos. Segue uma lista inicial.</p>

<ul>
  <li>Gleam - linguagem funcional estranhamente boa e confortável para uso.</li>
  <li>TabDigital - provedor de serviços Nextcloud</li>
  <li>Termux - uso muito para transformar meu tablet em um dispositivo útil para trabalho</li>
</ul>

<p>Novos projetos provavelmente irão aparecer, mas esses eu gostaria de contribuir agora. São importantes para mim atualmente e eu gostaria de ajudar esses projetos a serem mais sustentáveis.</p>]]></content><author><name></name></author><category term="open-source" /><summary type="html"><![CDATA[Há algum tempo parei de pagar o Dropbox Plus, mas ainda não vejo problema nenhum de usar Netflix, Crunchyroll, Amazon Prime e etc. Esses serviços são oferecidos por grandes empresas e baseados primariamente em software fechado. Em compensação, mal pago um tostão para os desenvolvedores de softwares que uso há anos, como Fedora, Ubuntu, Krita, Inkscape e Firefox. Sem falar em outros mais recentes que admiro, como Gleam, UBPorts e Nextcloud.]]></summary></entry><entry><title type="html">Criando um editor de texto - parte 1</title><link href="/editor-de-texto/2024/05/23/editor-de-texto-1.html" rel="alternate" type="text/html" title="Criando um editor de texto - parte 1" /><published>2024-05-23T00:00:00-03:00</published><updated>2024-05-23T00:00:00-03:00</updated><id>/editor-de-texto/2024/05/23/editor-de-texto-1</id><content type="html" xml:base="/editor-de-texto/2024/05/23/editor-de-texto-1.html"><![CDATA[<p>Eu gosto de editores de texto.Mesmo. Já testei uma porção deles e de todos os tipos, desde neovim e Emacs até os menos conhecidos como helix e micro. Também uso editores de texto GUI e já experimentei um monte deles. Aliás, minhas contribuições mais complexas no elementary linux foram justamente no editor de texto Code.</p>

<p>Resolvi então explorar como construir um editor de texto do zero. E não só isso: um editor de texto que funcione no terminal. Meus dois objetivos com isso são</p>

<ol>
  <li>explorar os tipos de algoritmos envolvidos na criação de um editor de texto</li>
  <li>usar a linguagem funcional Gleam para construir um programa complexo</li>
</ol>

<p>A cada novo texto irei contando um pouco deste processo e teremos uma versão mais sofisticada do editor. Aliás, nas primeiras versões nosso “editor” não vai nem modificar os arquivos, só mostrá-los.</p>

<p>Essa é uma outra vantagem de construir no terminal: ter a chance de se aprofundar em problemas que já são resolvidos completamente por outras bibliotecas. Por exemplo, um GtkSourceView já possui recursos prontos para syntax highlight e auto complete. Isso ajuda a criar um editor rápido e poupa um grande trabalho, mas não necessariamente ajuda a aprender como resolver esses problemas.</p>

<p>Essa parte 1 da série explica um pouco sobre o que é um terminal em sistemas POSIX e como podemos controlá-lo para criar programas complexos.</p>

<p>Para começar, todo programa de terminal como Gnome Console ou Konsole emula um dispositivo terminal “de verdade” (físico mesmo) que estava ligado ao sistema principal via rede. Nessa configuração o terminal (e seu teclado) podia estar conectado ao sistema via linha telefônica e estar a quilômetros de distância.</p>

<p>Obviamente o terminal podia exibir caracteres e receber entrada via teclado. O que não é tão óbvio é que o terminal também pode ser controlado via sequências especiais de bytes. Podemos mudar as cores do texto e do fundo, posicionar o cursor em qualquer lugar da tela e rolar todas as linhas para cima (ou para baixo). Em terminais modernos conseguimos também mostrar caracteres unicode (com acentos, orientais e/ou ícones). Ou seja, o terminal é excelente para programas que tratam texto e pode ser muito interativo. Dá até para habilitar suporte a mouse!</p>

<p>Uma outra vantagem do terminal é que os programas podem ser muito leves. As opções de layout são limitadas e a interação em geral é diferente de programas gráficos. Um exemplo clássico é a rolagem de tela: vários programas otimizam ao máximo essa operação, porém o terminal funciona em um esquema de páginas em que a maioria das rolagens de tela apagam pelo menos metade do texto. Ou seja, o que pode ser importante para conteúdos ricos em gráficos e interações via toque também pode ser irrelevante em uma aplicação que só trabalha com texto.</p>

<p>Vamos então a como controlar o terminal. Temos uma série de sequencias especiais que começam com dois caracteres de controle. Ao enviar os bytes <code class="language-plaintext highlighter-rouge">ESC</code>+<code class="language-plaintext highlighter-rouge">[</code> o terminal irá interpretar a sequência de bytes seguintes como um comando.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ESC[2J</code> limpa a tela inteira</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[L;CH</code> move o cursor para a linha L e coluna C</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[1m</code> liga o modo negrito. Todo texto a seguir será escrito em negrito</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[0m</code> reseta para o formato padrão do terminal</li>
  <li><code class="language-plaintext highlighter-rouge">ESC[38;2;127;255;255m</code> muda a cor para RGB(127, 255, 255)
Também temos códigos de controle com 1 caracter só, que são enviados com a tecla Ctrl pressionada. Por exemplo, Ctrl+J envia um caracter de nova linha para o terminal. A Wikipedia tem uma lista não exaustiva de códigos de controle.</li>
</ul>

<p>Isso já nos permite escrever programas que mostram textos coloridos e posicionam o cursor em qualquer lugar da tela! Veja o exemplo abaixo em Gleam</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/io  
  
pub fn main() {  
 io.print("\u{1b}[10;5H \u{1b}[1m IGOR!\u{1b}[0m normal!")  
 io.print("\u{1b}[38;2;127;255;255mCOR!")  
    
}</code></pre></figure>

<p>É feio? Muito, mas podemos melhorar muito a legibilidade com funções. O exemplo abaixo é bem mais legível.</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/io  
  
fn bold(s) {  
  "\u{1b}[1m" &lt;&gt; s &lt;&gt; "\u{1b}[0m"  
}  
  
pub fn main() {    
 io.println(bold("IGOR") &lt;&gt; " normal")     
}</code></pre></figure>

<p>Um aspecto final do funcionamento do terminal é o tratamento da entrada (line discipline, em linux). A maneira padrão é o modo cooked, em que o terminal só envia os dados entrados pelo usuário após a tecla Enter ser pressionada. Também podemos habilitar o modo raw, em que toda tecla é disponibilizada instantâneamente para o programa.</p>

<blockquote>
  <p>:warning: A rigor cada modo é um conjunto de opções mais simples oferecidas pelo kernel do Linux para configurar o terminal.</p>
</blockquote>

<p>É possível usar a API posix para configurar o terminal, mas nesse momento vamos facilitar nossa vida e usar a ferramenta de comando ˋsttyˋ. Ela permite configurar todas opções do terminal e pode ser chamada em Gleam usando o pacote shellout. O exemplo abaixo mostra um programa que limpa o terminal, o coloca em modo raw, e mostra na linha 3 coluna 0 o último caractere digitado. O programa para quando digitamos q.</p>

<figure class="highlight"><pre><code class="language-gleam" data-lang="gleam">import gleam/int  
import gleam/io  
import gleam/result  
import shellout  
  
@external(erlang, "io", "get_chars")  
pub fn get_chars(prompt: String, count: int) -&gt; String  
  
fn clear() {  
 io.print("\u{1b}[2J")  
}  
  
fn raw_mode_enter() {  
 shellout.command("stty", ["raw", "-echo"], ".", [])  
}  
  
fn raw_mode_end() {  
 shellout.command("stty", ["-raw", "echo"], ".", [])  
}  
  
fn move_cursor(row: Int, col: Int) {  
 io.print("\u{1b}[" &lt;&gt; int.to_string(row) &lt;&gt; ";" &lt;&gt; int.to_string(col) &lt;&gt; "H")  
}  
  
fn input_loop() {  
 let k = get_chars("", 1)  
 case k {  
   "q" -&gt; Nil  
   _ -&gt; input_loop()  
 }  
}  
  
pub fn main() {  
 clear()  
 raw_mode_enter()  
 move_cursor(3, 0)  
 input_loop()  
 raw_mode_end()  
}</code></pre></figure>

<p>Esse controle do terminal já nos dá quase tudo que precisamos para criar um editor de texto! No próximo texto falarei de arquivos e acabaremos com um “visualizador” de arquivos. Até :)</p>]]></content><author><name></name></author><category term="editor-de-texto" /><summary type="html"><![CDATA[Eu gosto de editores de texto.Mesmo. Já testei uma porção deles e de todos os tipos, desde neovim e Emacs até os menos conhecidos como helix e micro. Também uso editores de texto GUI e já experimentei um monte deles. Aliás, minhas contribuições mais complexas no elementary linux foram justamente no editor de texto Code.]]></summary></entry><entry><title type="html">Anotações em sala de aula</title><link href="/reflexao/2024/04/25/anotacoes.html" rel="alternate" type="text/html" title="Anotações em sala de aula" /><published>2024-04-25T00:00:00-03:00</published><updated>2024-04-25T00:00:00-03:00</updated><id>/reflexao/2024/04/25/anotacoes</id><content type="html" xml:base="/reflexao/2024/04/25/anotacoes.html"><![CDATA[<style>
    img[alt=centered] {
        display:block;
        margin-left: auto;
        margin-right: auto;
        max-width: 90%;
    }
</style>

<p>Seguindo minhas reflexões do <a href="https://igordsm.github.io/reflexao/2024/03/19/escrever-a-mao.html">último texto</a>, tenho notado em minhas aulas que o número de alunos que faz anotações à mão diminuiu muito desde que comecei em 2017. Não só isso: uma parte dos alunos parece não anotar <strong>nada</strong>, confiando basicamente em sua própria memória e no material de aula.</p>

<p>Para mim anotar, especialmente à mão, faz parte do meu processo de aprendizagem. Escrever me ajuda a organizar os pensamentos e, com isso, relacionar temas e solidificar a memória. Também me ajuda a focar: escrever é um ato que mistura uma ação mecânica (desenhar as letras e/ou digitar) com uma ação intelectual (pensar no que estou fazendo). Acaba sobrando pouco espaço para distrações quando escrevo.</p>

<p>Nem sempre anotar à mão é prático e vejo que muitos alunos ignoram a existência do papel e caneta. Porém, temos diversas ferramentas digitais úteis! Apps como <a href="https://app.mural.co/">Mural</a>, <a href="https://www.canva.com/">Canva</a> e <a href="https://excalidraw.com/">Excalidraw</a> permitem criar diagramas e organizar pensamentos da mesma forma que desenhar/escrever no papel. Acho muito bons os murais que o <a href="https://github.com/rafaelcorsi">Rafael Corsi</a> monta para organizar os experimentos/papers que faz.</p>

<p><img src="/assets/excalidraw.png" alt="centered" /></p>

<p>Além disso, nas salas no Insper temos lousas nas paredes inteiras e algumas portáteis que podemos usar para rascunhar e pensar em grupo. Opções não faltam, mas parece que a ideia de ter anotações e usá-las para raciocinar simplesmente sumiu da educação que os alunos receberam antes de entrar na faculdade.</p>

<p>Encucado com isso fui pesquisar o que a ciência diz disso e encontrei artigoes interessantes. Uma busca no <a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=science+text+comprehension+&amp;btnG=">Google Scholar</a> por “science text comprehension” traz diversos estudos sobre como aprender com textos acadêmicos expositivos. E vários citam estratégias bem “tradicionais”: desenhar, imaginar o conteúdo do texto, sumarizar e explicar o texto para si mesmo. O que me marca é que é necessário <strong>intenção e ação</strong> para aprender de um texto, e que isso é uma habilidade treinável e não um traço inerente a alguns estudantes.</p>

<p>Por enquanto vou parar por aqui, mas penso em pesquisar um pouco mais sobre isso e quem sabe adicionar links e recursos sobre como ler e aprender melhor. Assim como o anterior, esse texto não tem muito fim. Quando eu conseguir organizar melhor as informações que pesquisei sobre compreensão de textos devo continuar a escrever sobre esse assunto.</p>]]></content><author><name></name></author><category term="reflexao" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Não se escreve mais à mão?</title><link href="/reflexao/2024/03/19/escrever-a-mao.html" rel="alternate" type="text/html" title="Não se escreve mais à mão?" /><published>2024-03-19T00:00:00-03:00</published><updated>2024-03-19T00:00:00-03:00</updated><id>/reflexao/2024/03/19/escrever-a-mao</id><content type="html" xml:base="/reflexao/2024/03/19/escrever-a-mao.html"><![CDATA[<style>
    img[alt=centered] {
        display:block;
        margin-left: auto;
        margin-right: auto;
        max-width: 90%;
    }
</style>

<p>Tenho visto em minhas aulas de Algoritmos que a maioria da sala tem uma certa resistência a usar papel e caneta durante as atividades de sala. Em geral fazemos muitas simulações de algoritmos, procuramos exemplos de entradas difíceis e escrevemos pseudo-código. Escrever, desenhar e rabiscar foram parte importante do meu processo de pensar e encontrar soluções para estas tarefas.</p>

<p>Acho interessante ver alguns tentando simular coisas complicadas de cabeça ou escrever pseudo-código sem ter uma entrada do lado para ir testando. Usar somente editores de texto no PC me parece bem mais limitado do que poder criar a minha própria organização dos pensamentos no papel. E não é falta de material bom: toda sala tem papel de rascunho disponível e umas lousas portáteis como as abaixo para ajudar a rascunhar e pensar em grupo.</p>

<p><img src="/assets/lousas.jpeg" alt="centered" /></p>

<p>Eu sempre tento levar uma delas comigo para discutir dúvidas e parece ajudar a concretizar os pensamentos, mas noto que a maioria não tem esse costume. Para mim escrever ajuda com os seguintes pontos:</p>

<ul>
  <li>focar em uma coisa só e evitar distrações</li>
  <li>relacionar temas distintos criando uma espécie de mapa conceitual improvidado</li>
  <li>fazer brainstorm sozinho ao ir escrevendo pensamentos rápido e sem filtrar muito</li>
  <li>quando estou ansioso ou inquieto, ajuda a organizar meus pensamentos e me centrar no que quero fazer no momento atual.</li>
</ul>

<p>Não acho um problema fazer diferente de mim, só achei intrigante que não consegui identificar qual seria o processo dos alunos para estas tarefas. Fico até pensando se não seriam um tema de pesquisa legal. Certamente já existem estudos nessa direção e vê-los aplicados à computação pode ser muito interessante para mim.</p>

<p>Enfim, esse texto não tem muita conclusão mesmo. É só uma observação do meu dia a dia… Tive a ideia de fazer isso escrevendo à mão ideias de post =)</p>]]></content><author><name></name></author><category term="reflexao" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Datas em formato Excel OpenXML usando Nim</title><link href="/code/2024/01/26/datas-excel.html" rel="alternate" type="text/html" title="Datas em formato Excel OpenXML usando Nim" /><published>2024-01-26T00:00:00-03:00</published><updated>2024-01-26T00:00:00-03:00</updated><id>/code/2024/01/26/datas-excel</id><content type="html" xml:base="/code/2024/01/26/datas-excel.html"><![CDATA[<p>Representar  dados em computadores é uma tarefa que parece fácil mas que é na verdade bem complicada. Vou falar um pouco aqui sobre uma experiência que tive trabalhando com planilhas Excel na linguagem <a href="https://nim-lang.org">Nim</a> com a biblioteca <a href="https://github.com/khchen/xl/">xl</a>.</p>

<p>Arquivos com extensão <em>.xlsx</em> estão no formato OpenXML, um padrão com especificação aberta que é basicamente um arquivo <em>zip</em> com estrutura fixa de pastas e uma porção de arquivos <em>.xml</em> dentro. Não é exatamente complicado e só de abrir e ler os nomex e conteúdos dos arquivos já daria para entender mais ou menos como as coisas funcionam.</p>

<p>Menos para datas… Datas já são um <a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">tema bem complicado</a>, então ler datas em um arquivo externo é pedir pra sofrer.</p>

<p>Examinando os valores das células, vi que a data para o dia <em>22 de dezembro de 2023</em> terá o valor …. Não ajuda muito, certo? De acordo com a documentação do formato OpenXML, datas estão no formato <em>1900-compatibility mode</em>. A explicação rápida é que o número representa dias após a data base <em>01 de janeiro de 1900</em>. Isso não batia muito com minhas contas e <a href="http://www.ericwhite.com/blog/dates-in-spreadsheetml/">esse site</a> muita coisa. No fim acabei encontrando também a <a href="https://learn.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system">documentação oficial sobre este tópico</a>, mas achei o primeiro link mais didático.</p>

<p>Para começar, a explicação rápida é enganosa. A data <em>01 de janeiro de 1900</em> tem valor <strong>1</strong>, portanto o número representa o número de dias após <em>31 de dezembro de 1899</em>. Pode ser intuitivo para não programadores, mas pra nós programadores que indexamos o primeiro elemento como 0 é bastante confuso.</p>

<p>Tem mais: infelizmente um software antigo e muito famoso na década de 80 e 90 chamado Lotus 123 criou essa representação, mas errou feio e considerou que 1900 era ano bisexto (e não é!). Assim, uma tonelada de planilhas foram criadas com a contagem de dias errada e os programas concorrentes precisavam ser capazes de ler e intrepretar esses dados. Por isso esse modo de armazenar datas é chamado <em>1900 compatibility mode</em>. É compatível com um software de 30 anos atrás que ninguém mais usa, mas que criou uma quantidade enorme de dados nesse formato e que precisam ser lidos…</p>

<p><img src="https://winworldpc.com/res/img/screenshots/2e2a25fbb4a2f9b686b7b161059cfb5f7c568c8f5d572b6382f0ebe0fb8c35c7.png" alt="" /></p>

<p>Aliás, olha só que doideira: nem os softwares de planilha mais usados (Excel, LibreOffice e OnlyOffice) concordam e e mostram datas diferentes para a mesma célula com data <em>05 de janeiro de 1900</em>. Pelo menos eles concordam quando a data passa de <em>01 de março de 1900</em>….</p>

<p><img src="/assets/datas-diferentes-excel.png" alt="" /></p>

<p>Vamos ver agora o código atual da <code class="language-plaintext highlighter-rouge">xl</code> que devolve um <code class="language-plaintext highlighter-rouge">datetime</code> a partir de uma célula com dados no formato que descrevi acima.</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">date</span><span class="o">*</span><span class="p">(</span><span class="n">xc</span><span class="p">:</span> <span class="n">XlCell</span><span class="p">):</span> <span class="n">DateTime</span> <span class="o">=</span>
  <span class="sd">## Assume the number of cell is a date and return it.</span>
  <span class="sd">## Using 1900 date system: a serial number that represents the number of days</span>
  <span class="sd">## elapsed since January 1, 1900.</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">dateTime</span><span class="p">(</span><span class="mi">1900</span><span class="p">,</span> <span class="n">mJan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">+=</span> <span class="n">initDuration</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">xc</span><span class="p">.</span><span class="n">number</span> <span class="o">*</span> <span class="mi">86400</span><span class="p">))</span>
</code></pre></div></div>

<p>A intuição do código faz todo sentido: um dia tem <code class="language-plaintext highlighter-rouge">84600</code> segundos, então basta somar isso vezes o número de dias para chegar na data correta. Mas está errado :S O número de dias varia conforme a data é antes ou depois de 29 de fevereiro de 1900. Além disso,o dia 01 de janeiro de 1900 é o número sequencial <strong>1</strong>!</p>

<p>Estou tentando me envolver novamente com projetos abertos e <em>Nim</em> é uma linguagem interessante. Por isso <a href="https://github.com/khchen/xl/pull/6">enviei um PR</a> com uma correção (e testes!) e espero que seja aprovado logo. Estou usando essa lib em um projeto simples para converter planos de aula em arquivos <em>.ics</em> para colocar no meu calendário. Posto sobre isso quando estiver mais pronto.</p>]]></content><author><name></name></author><category term="code" /><summary type="html"><![CDATA[Representar dados em computadores é uma tarefa que parece fácil mas que é na verdade bem complicada. Vou falar um pouco aqui sobre uma experiência que tive trabalhando com planilhas Excel na linguagem Nim com a biblioteca xl.]]></summary></entry></feed>