{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About me Hi, I'm Igor. I'm currently a Teaching Professor at Insper and also an open source software developer. Most of my contributions go to elementary linux , although I also contribute to other projects occasionally. News (2021-12-24) Vala reactive programming - part 2 - Receiveing and sending information from/to components (2021-12-06) Vala reactive programming - Creating Vala apps that behave like React frontend apps (kinda) Curriculum Vitae Bachelors and PhD in Computer Science ( University of S\u00e3o Paulo ) under the supervision of profs. Roberto Hirata Jr and Nina Hirata PhD internship (INSA-Rouen) with prof. St\u00e9phane Canu Assistant Teaching Professor in Computer Science and Engineering at Insper A list of academic publications can be found in my Google Scholar profile . Projects Most of my time is currently devoted to teaching and writing educational open source software. Course materials are open and published at Insper's github org . Educational software is published at our second github org . When I'm not involved with teaching I contribute to open source software. I believe that writing software that people use is important both as a learning experience and as way to influence the way we do computing. Open Development course (Pt-BR): students contribute to FLOSS software and experience the contact with the community of people that develop it. elementary : I contribute mainly with Camera, Code and Terminal, but also have minor contributions in other places. (details) Support You can show appreciation of what I'm doing by buying me a coffe and/or following me on twitter at @igor_montagner .","title":"About me"},{"location":"#about-me","text":"Hi, I'm Igor. I'm currently a Teaching Professor at Insper and also an open source software developer. Most of my contributions go to elementary linux , although I also contribute to other projects occasionally.","title":"About me"},{"location":"#news","text":"(2021-12-24) Vala reactive programming - part 2 - Receiveing and sending information from/to components (2021-12-06) Vala reactive programming - Creating Vala apps that behave like React frontend apps (kinda)","title":"News"},{"location":"#curriculum-vitae","text":"Bachelors and PhD in Computer Science ( University of S\u00e3o Paulo ) under the supervision of profs. Roberto Hirata Jr and Nina Hirata PhD internship (INSA-Rouen) with prof. St\u00e9phane Canu Assistant Teaching Professor in Computer Science and Engineering at Insper A list of academic publications can be found in my Google Scholar profile .","title":"Curriculum Vitae"},{"location":"#projects","text":"Most of my time is currently devoted to teaching and writing educational open source software. Course materials are open and published at Insper's github org . Educational software is published at our second github org . When I'm not involved with teaching I contribute to open source software. I believe that writing software that people use is important both as a learning experience and as way to influence the way we do computing. Open Development course (Pt-BR): students contribute to FLOSS software and experience the contact with the community of people that develop it. elementary : I contribute mainly with Camera, Code and Terminal, but also have minor contributions in other places. (details)","title":"Projects"},{"location":"#support","text":"You can show appreciation of what I'm doing by buying me a coffe and/or following me on twitter at @igor_montagner .","title":"Support"},{"location":"elementary/","text":"elementary OS Camera I've worked with the gstreamer rewrite of the camera backend, adding support for multiple cameras and taking full resolution images. I also added simple image controls such as brightness, contrast and mirror. Accepted Pull Requests Take full resolution pictures When no camera is present show view and disable all controls Add audio recording elements to record_bin Send notification when recording has finished Add brightness and contrast adjustments Add option to mirror the webcam image Add option to switch cameras Use gst.DeviceMonitor to list video sources Setting v4l device now works correctly Code My most noteworthy contributions to Code are the Markdown plugin and (in progress) Snippets plugin and Word completion rewrite . Works in progress Rewrite word completion to play nice with other completion providers Snippets plugin: initial version Accepted Pull Requests Ctrl+Tab for next document and Ctrl+Shift+Tab for previous one Add Markdown plugin List Edit Mode for Markdown Rename tabs with the same title Opens newly created file Fix crash when creating new window from tab drop Update ChooseProjectButton when a project is closed Change setting to Visible whitespace Distinguish projects with same folder name Terminal I do random bug fixes in Terminal. I haven't tackled a more focused project yet. Works in Progress Focus current tab Show zoom level in the center of terminal Accepted Pull Requests Add text to paste in details pane for UnsafePasteDialog Paste Protection dialog cancels pasting if Escape is pressed Add Reload item to terminal tabs","title":"elementary OS"},{"location":"elementary/#elementary-os","text":"","title":"elementary OS"},{"location":"elementary/#camera","text":"I've worked with the gstreamer rewrite of the camera backend, adding support for multiple cameras and taking full resolution images. I also added simple image controls such as brightness, contrast and mirror.","title":"Camera"},{"location":"elementary/#accepted-pull-requests","text":"Take full resolution pictures When no camera is present show view and disable all controls Add audio recording elements to record_bin Send notification when recording has finished Add brightness and contrast adjustments Add option to mirror the webcam image Add option to switch cameras Use gst.DeviceMonitor to list video sources Setting v4l device now works correctly","title":"Accepted Pull Requests"},{"location":"elementary/#code","text":"My most noteworthy contributions to Code are the Markdown plugin and (in progress) Snippets plugin and Word completion rewrite .","title":"Code"},{"location":"elementary/#works-in-progress","text":"Rewrite word completion to play nice with other completion providers Snippets plugin: initial version","title":"Works in progress"},{"location":"elementary/#accepted-pull-requests_1","text":"Ctrl+Tab for next document and Ctrl+Shift+Tab for previous one Add Markdown plugin List Edit Mode for Markdown Rename tabs with the same title Opens newly created file Fix crash when creating new window from tab drop Update ChooseProjectButton when a project is closed Change setting to Visible whitespace Distinguish projects with same folder name","title":"Accepted Pull Requests"},{"location":"elementary/#terminal","text":"I do random bug fixes in Terminal. I haven't tackled a more focused project yet.","title":"Terminal"},{"location":"elementary/#works-in-progress_1","text":"Focus current tab Show zoom level in the center of terminal","title":"Works in Progress"},{"location":"elementary/#accepted-pull-requests_2","text":"Add text to paste in details pane for UnsafePasteDialog Paste Protection dialog cancels pasting if Escape is pressed Add Reload item to terminal tabs","title":"Accepted Pull Requests"},{"location":"other-floss/","text":"Other projects I also occasionally contribute to other FLOSS software I use in a daily basis. Here's a list of these contributions: Focalboard [GH-1167] Add build info to version tooltip [GH 483] Linux-app: discover executable folder and use it in config instead of ./","title":"Other projects"},{"location":"other-floss/#other-projects","text":"I also occasionally contribute to other FLOSS software I use in a daily basis. Here's a list of these contributions:","title":"Other projects"},{"location":"other-floss/#focalboard","text":"[GH-1167] Add build info to version tooltip [GH 483] Linux-app: discover executable folder and use it in config instead of ./","title":"Focalboard"},{"location":"talks/","text":"Talks Here's a list of some talks I gave in the last years. How to contribute to elementary Experi\u00eancias mentorando contribui\u00e7\u00f5es a software livre na faculdade Entenda porque fazer faculdade ainda vale a pena","title":"Talks"},{"location":"talks/#talks","text":"Here's a list of some talks I gave in the last years.","title":"Talks"},{"location":"talks/#how-to-contribute-to-elementary","text":"","title":"How to contribute to elementary"},{"location":"talks/#experiencias-mentorando-contribuicoes-a-software-livre-na-faculdade","text":"","title":"Experi\u00eancias mentorando contribui\u00e7\u00f5es a software livre na faculdade"},{"location":"talks/#entenda-porque-fazer-faculdade-ainda-vale-a-pena","text":"","title":"Entenda porque fazer faculdade ainda vale a pena"},{"location":"blog/2021-12-06/","text":"Vala reactive programming I've been doing some web programming using preact these last weeks and one of the things that impressed the most was the way logic and UI are split in code. When doing functional components this is specially explicit. Your function returns whatever should be displayed by the component and receives a props object containing all the information the components need to render. A component rerenders when some of its props are changed, either because an external component made changes or in response to an event. IMHO, this really helps to organize code and separate concerns. All the logic is written in terms of the components' properties. The GUI is updated in response to changes in the properties in order to synchronize the component state with what is shown on screen. We can also achieve this in Vala using properties and bindings from GLib. In this article we will produce a login screen that validates the username and password fields. All code is available at the part1 folder of the example code in Github . Important : The repo contains many iterations of the code presented in this article. A comment containing the name of the original file is shown at the top of each code listing. Let's start with the basic code to build the form above. This is just standard GTK code: all the ui elements are created in the construct method. The original file ( v1/main.vala ) also contains a Gtk.Application subclass that handles initialization and showing our form. Vala tip : the construct block runs during an object's creation and after named constructors are called. // excerpt from v1.vala class LoginForm : Gtk.Grid { // ...... construct { width_request = 300; margin = 10; column_homogeneous = false; expand = false; valign = Gtk.Align.CENTER; halign = Gtk.Align.CENTER; var username_field = new Gtk.Entry () { hexpand = true, margin = 4 }; var password_field = new Gtk.Entry () { hexpand = true, margin = 4 }; var validation_warning = new Gtk.Label (\"\") { wrap = true, height_request = 50 }; var login_btn = new Gtk.Button.with_label (\"Login\") { expand = false, halign = Gtk.Align.END }; attach (new Gtk.Label (\"Username\"), 0, 0); attach (username_field, 1, 0); attach (password_field, 1, 1); attach (new Gtk.Label (\"Password\"), 0, 1); attach (validation_warning, 1, 2); attach (login_btn, 1, 3); show_all (); } } There's no interactivity in this form yet. In fact, it already starts in an inconsistent state: the Login button is enabled even though block fields are empty. We could fix this simply by setting sensitive=false in login_btn initialization, but we won't. Instead we will create a property called is_valid and bind its value to login_btn.sensitive . Every time one of the values change the other is instantly updated. Bindings can also be created with many values as long as a cicle is not introduced. Let's use this now in our program: first we create a property is_valid and then we use bind_property to bind its value to login_btn.sensitive . Our binding flags indicate that the binding is bidirectional and that the value is synchronized when the binding is created . // excerpt from v2.vala class LoginForm : Gtk.Grid { public bool is_valid { get; set; default = false; } ova d'\u00e1gua, e foi constru\u00eddo para suportar ambientes dif\u00edceis. PADR\u00d5ES MILITARES O Cat B26 \u00e9 robusto, resistente e testado em condi\u00e7\u00f5es extremas. \u00c0 prova de respingos, \u00e0 prova de poeira e resistente a temperaturas extremas. Bateria 1500 mAh At\u00e9 13 horas de conversa\u00e7\u00e3o e 18 dias em standby com uma \u00fanica carga, o Cat B26 \u00e9 constru\u00eddo com uma bateria grande para mant\u00ea-lo trabalhando por mais tempo. Imperme\u00e1vel \u00c0 prova de respingos. Al\u00e9m do Robusto: Prote\u00e7\u00e3o de tela (IP68) Resistente \u00e0 areia, poeira e sujeira/ Padr\u00f5es militares MIL SPEC 810G/ Choque t\u00e9rmico Lida com diferen\u00e7as de temperatura de baixa a alta entre -25 \u00b0 C (-13 \u00b0 F) - 55 \u00b0 C (131 \u00b0 F) por at\u00e9 4 horas/ Resistente \u00e0 vibra\u00e7\u00e3o Categoria 4/ Resistente \u00e0 umidade e n\u00e9voa de sal sim BATERIA: Capacidade 1500mAh/ Tipo \u00cdon de l\u00edtio remov\u00edvel/ Hora de conversa\u00e7\u00e3o At\u00e9 13 horas/ Tempo de espera At\u00e9 18 dias. Conectividade: Jack de \u00e1udio 3.5mm/ Bluetooth 2.1/ USB micro-USB 2.0/ Tipo Sim Dual SIM, tamanho padr\u00e3o (2FF). Processador: Tipo de processador Spreadtrum SC6531F/ Sistema operacional Propriet\u00e1rio. Tamanho Exibi\u00e7\u00e3o: Dimens\u00f5es 139 x 60 x 16 mm/ Peso 150g/ Exibi\u00e7\u00e3o Visor QVGA de 2,4 ?. C\u00e2mera: 2MP. Mem\u00f3ria: ROM 8MB/ RAM: 8MB/ Expans\u00edvel via cart\u00e3o microSD (at\u00e9 32 GB). Itens Inclusos: 01 Aparelho de Celular/ 01 Cabo USB -V8/ 01 Bateria/ 01 Carregador/ 01 Manual de instru\u00e7\u00f5es 03 Meses de garantia contra defeitos de fabrica\u00e7\u00e3o diretamente com o lojista. construct { // GUI creation code bind_property (\"is_valid\", login_btn, \"sensitive\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); } Now the login button is disabled when the app starts and will remain so until we set is_valid=true . Unfortunately this never happens, so let's add a property username and bind it to username_field.text . When username is set we check if its length is larger than 0 and set is_valid accordingly. // excerpt from v3.vala class LoginForm : Gtk.Grid { public bool is_valid { get; set; default = false; } private string _username = \"\"; public string username { get { return _username; } set { _username = value; if (value.length > 0) { is_valid = true; } else { is_valid = false; } }} construct { // GUI creation code bind_property (\"is_valid\", login_btn, \"sensitive\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); bind_property (\"username\", username_field, \"text\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); } Run the app and test the new validation: the login button should be disable when the app starts and respond to is_valid . IMHO, the impressive part of this code is that all GUI code is on construct and our logic is written only in terms of properties. When we update the Widget's properties the UI will update in response, so our application state is always consistent. Now the final step is to set validation_error to a meaningful message. We can do this with another property binding. To make code more readble we also refactor all our validation code into a function void validate_form () . // excerpt from v4.vala class LoginForm : Gtk.Grid { public string validation_error { get; set; default = \"\"; } public string username { get { return _username; } set { _username = value; validate_form (); } } //.... construct { // .... bind_property (\"validation_error\", validation_warning, \"label\", BindingFlags.DEFAULT | BindingFlags.SYNC_CREATE); } private void validate_form () { if (_username.length == 0) { is_valid = false; validation_error = \"Empty username\"; return; } is_valid = true; validation_error = \"\"; } And that's it for the username field. We can do exactly the same for the password field and arrive at the final code available at final.vala in the example repository . Another interesting project is Blueprint compiler , which creates a sort of DSL for Gtk components. So, what do you think about this style of Gtk programming? Join the discussion here . If you liked this post consider buying me a coffe and/or following me on twitter at @igor_montagner .","title":"Vala reactive programming"},{"location":"blog/2021-12-06/#vala-reactive-programming","text":"I've been doing some web programming using preact these last weeks and one of the things that impressed the most was the way logic and UI are split in code. When doing functional components this is specially explicit. Your function returns whatever should be displayed by the component and receives a props object containing all the information the components need to render. A component rerenders when some of its props are changed, either because an external component made changes or in response to an event. IMHO, this really helps to organize code and separate concerns. All the logic is written in terms of the components' properties. The GUI is updated in response to changes in the properties in order to synchronize the component state with what is shown on screen. We can also achieve this in Vala using properties and bindings from GLib. In this article we will produce a login screen that validates the username and password fields. All code is available at the part1 folder of the example code in Github . Important : The repo contains many iterations of the code presented in this article. A comment containing the name of the original file is shown at the top of each code listing. Let's start with the basic code to build the form above. This is just standard GTK code: all the ui elements are created in the construct method. The original file ( v1/main.vala ) also contains a Gtk.Application subclass that handles initialization and showing our form. Vala tip : the construct block runs during an object's creation and after named constructors are called. // excerpt from v1.vala class LoginForm : Gtk.Grid { // ...... construct { width_request = 300; margin = 10; column_homogeneous = false; expand = false; valign = Gtk.Align.CENTER; halign = Gtk.Align.CENTER; var username_field = new Gtk.Entry () { hexpand = true, margin = 4 }; var password_field = new Gtk.Entry () { hexpand = true, margin = 4 }; var validation_warning = new Gtk.Label (\"\") { wrap = true, height_request = 50 }; var login_btn = new Gtk.Button.with_label (\"Login\") { expand = false, halign = Gtk.Align.END }; attach (new Gtk.Label (\"Username\"), 0, 0); attach (username_field, 1, 0); attach (password_field, 1, 1); attach (new Gtk.Label (\"Password\"), 0, 1); attach (validation_warning, 1, 2); attach (login_btn, 1, 3); show_all (); } } There's no interactivity in this form yet. In fact, it already starts in an inconsistent state: the Login button is enabled even though block fields are empty. We could fix this simply by setting sensitive=false in login_btn initialization, but we won't. Instead we will create a property called is_valid and bind its value to login_btn.sensitive . Every time one of the values change the other is instantly updated. Bindings can also be created with many values as long as a cicle is not introduced. Let's use this now in our program: first we create a property is_valid and then we use bind_property to bind its value to login_btn.sensitive . Our binding flags indicate that the binding is bidirectional and that the value is synchronized when the binding is created . // excerpt from v2.vala class LoginForm : Gtk.Grid { public bool is_valid { get; set; default = false; } ova d'\u00e1gua, e foi constru\u00eddo para suportar ambientes dif\u00edceis. PADR\u00d5ES MILITARES O Cat B26 \u00e9 robusto, resistente e testado em condi\u00e7\u00f5es extremas. \u00c0 prova de respingos, \u00e0 prova de poeira e resistente a temperaturas extremas. Bateria 1500 mAh At\u00e9 13 horas de conversa\u00e7\u00e3o e 18 dias em standby com uma \u00fanica carga, o Cat B26 \u00e9 constru\u00eddo com uma bateria grande para mant\u00ea-lo trabalhando por mais tempo. Imperme\u00e1vel \u00c0 prova de respingos. Al\u00e9m do Robusto: Prote\u00e7\u00e3o de tela (IP68) Resistente \u00e0 areia, poeira e sujeira/ Padr\u00f5es militares MIL SPEC 810G/ Choque t\u00e9rmico Lida com diferen\u00e7as de temperatura de baixa a alta entre -25 \u00b0 C (-13 \u00b0 F) - 55 \u00b0 C (131 \u00b0 F) por at\u00e9 4 horas/ Resistente \u00e0 vibra\u00e7\u00e3o Categoria 4/ Resistente \u00e0 umidade e n\u00e9voa de sal sim BATERIA: Capacidade 1500mAh/ Tipo \u00cdon de l\u00edtio remov\u00edvel/ Hora de conversa\u00e7\u00e3o At\u00e9 13 horas/ Tempo de espera At\u00e9 18 dias. Conectividade: Jack de \u00e1udio 3.5mm/ Bluetooth 2.1/ USB micro-USB 2.0/ Tipo Sim Dual SIM, tamanho padr\u00e3o (2FF). Processador: Tipo de processador Spreadtrum SC6531F/ Sistema operacional Propriet\u00e1rio. Tamanho Exibi\u00e7\u00e3o: Dimens\u00f5es 139 x 60 x 16 mm/ Peso 150g/ Exibi\u00e7\u00e3o Visor QVGA de 2,4 ?. C\u00e2mera: 2MP. Mem\u00f3ria: ROM 8MB/ RAM: 8MB/ Expans\u00edvel via cart\u00e3o microSD (at\u00e9 32 GB). Itens Inclusos: 01 Aparelho de Celular/ 01 Cabo USB -V8/ 01 Bateria/ 01 Carregador/ 01 Manual de instru\u00e7\u00f5es 03 Meses de garantia contra defeitos de fabrica\u00e7\u00e3o diretamente com o lojista. construct { // GUI creation code bind_property (\"is_valid\", login_btn, \"sensitive\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); } Now the login button is disabled when the app starts and will remain so until we set is_valid=true . Unfortunately this never happens, so let's add a property username and bind it to username_field.text . When username is set we check if its length is larger than 0 and set is_valid accordingly. // excerpt from v3.vala class LoginForm : Gtk.Grid { public bool is_valid { get; set; default = false; } private string _username = \"\"; public string username { get { return _username; } set { _username = value; if (value.length > 0) { is_valid = true; } else { is_valid = false; } }} construct { // GUI creation code bind_property (\"is_valid\", login_btn, \"sensitive\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); bind_property (\"username\", username_field, \"text\", BindingFlags.BIDIRECTIONAL | BindingFlags.SYNC_CREATE); } Run the app and test the new validation: the login button should be disable when the app starts and respond to is_valid . IMHO, the impressive part of this code is that all GUI code is on construct and our logic is written only in terms of properties. When we update the Widget's properties the UI will update in response, so our application state is always consistent. Now the final step is to set validation_error to a meaningful message. We can do this with another property binding. To make code more readble we also refactor all our validation code into a function void validate_form () . // excerpt from v4.vala class LoginForm : Gtk.Grid { public string validation_error { get; set; default = \"\"; } public string username { get { return _username; } set { _username = value; validate_form (); } } //.... construct { // .... bind_property (\"validation_error\", validation_warning, \"label\", BindingFlags.DEFAULT | BindingFlags.SYNC_CREATE); } private void validate_form () { if (_username.length == 0) { is_valid = false; validation_error = \"Empty username\"; return; } is_valid = true; validation_error = \"\"; } And that's it for the username field. We can do exactly the same for the password field and arrive at the final code available at final.vala in the example repository . Another interesting project is Blueprint compiler , which creates a sort of DSL for Gtk components. So, what do you think about this style of Gtk programming? Join the discussion here . If you liked this post consider buying me a coffe and/or following me on twitter at @igor_montagner .","title":"Vala reactive programming"},{"location":"blog/2021-12-24/","text":"Vala reactive programming: part 2 In the last article we explored how to use properties and bindings to create reactive style programming in Vala. All UI code was written in construct and all logic was represented by setting properties. UI was synchronized with the Widget state by binding properties to child widgets. Although the separation of concerns was nice, the example was too simple. There was only one component (the LoginForm ) and no information was neither (i) sent to other components; or (ii) received from other components. In this article we'll create a second form that receives the validated user from LoginForm to a second form. All the example code for this article is available at the part2 folder in this github repo Our component architecture will be based on the following principle: If two components share a parent, then it's the parent's resposability to connect them into a meaningful flow for the application Let's use this principle to extend the example from the last article and add a UserInfoForm after a succesful sign in. We'll start from the part2/v0.vala file. Dealing with events inside a component Events are a place where UI and logic code seems hard to separate. It's quite natural, for instance, to create a login_btn_click event handler that uses both GUI calls to get information from the UI and properties. Fortunately, Vala also provides us with a very nice way of separating this: lambda functions as event handlers. private void do_login () { // check database and validate login here // GUI calls are forbidden here, only properties and other methods can be used } construct { // .... login_btn.clicked.connect (() => { // extract all info from the UI using GUI calls do_login (); }); } In the lambda event handler we can extract all info from the UI using GUI calls and then pass this information along to a method. Since we can use bindings to link information between properties and GUI elements, the amount of code inside the lambda event handler can be quite small. In fact, it might only treat the event information and pass it on to a method that uses it. Another interesting point is that lambda can ignore arguments and their types, so if we don't use the GEvent that the handler is supposed to receive we can just ignore it in our declaration. This has two advantages: do_login does not receive Gtk.Event (or similar), which means it can be called from anywhere in the code, not only in response to an user generated event. Event handlers often receive different arguments depending on which event they handle. The lambda handler is used to treat this arguments, so do_login is not tied to a single type of event. Sending information out For sending information out of our components we can use signals . For instance, upon succesful login our LoginForm could emit a login_succesful signal that sends a User instance with the currently logged in user info. Now it's up to the parent of LoginForm to receive the signal and connect it to the next part of the application flow. First we modify LoginForm . For now our User class only contains the username property. Also, username is can only be assigned when creating an User instance. class User : Object { public string username { get; construct; } public User (string username) { Object (username: username); } } class LoginForm : Gtk.Grid { public signal void login_succesful (User u); // .... private void do_login() { login_succesful (new User (username)); } } Then we receive this information in our Application class: class Application : Gtk.Application { protected override void activate () { var win = new Gtk.ApplicationWindow (this); var login_form = new LoginForm (); login_form.login_succesful.connect ((u) => { print (\"%s\\n\", u.username); }); win.add (login_form); win.show (); } } The complete code is shown in part2/v1.vala . Intermission: Application mixes UI and logic Our Application class is not following the principles outline in the last article . Let's fix that while we add a new Gtk.Stack to hold our new HelloForm . class HelloForm : Gtk.Grid { construct { expand = true; valign = Gtk.Align.CENTER; halign = Gtk.Align.CENTER; var label = new Gtk.Label (\"Hello (username goes here)\"); attach (label, 0, 0); } } Instead of creating widgets inside Application we introduce a ApplicationWidget , a class with the sole purpose of creating the workflow of data between our components. Our first version is shown below. class ApplicationWidget : Gtk.Stack { construct { // ... var login_form = new LoginForm (); add_named (login_form, \"login_form\"); var hello_form = new HelloForm (); add_named (hello_form, \"hello_form\"); visible_child_name = \"login_form\"; } } The complete code is shown in part2/v2.vala . Our application works exactly the same as before, but now UI is separated from the rest of the app in Application as well. Receiving information from other components For receiving information from the \"outside\" worlds we have two options: regular instance methods or public properties. The advantage of using instance methods is that they can be directly connected to other components' signals. However, we must take care of only updating properties inside it so we don't mix UI and logic. We can also use public properties to receive data from the \"outside world\". Use methods if something besides updating the UI is necessary (i.e. pulling information from the database or the web) Use properties otherwise We add a user property to HelloForm so it can receive the currently logged in user. We then connect the components in our ApplicationWidget : class HelloForm : Gtk.Grid { public User user { get; set; } // ... } class ApplicationWidget : Gtk.Stack { construct { // ... login_form.login_succesful.connect ((u) => { hello_form.user = u; visible_child_name = \"hello_form\"; }); } } The final part of this is to connect a change in HelloForm.user with the UI. A first could be creating a binding between user.username to the label text. This won't work, as we are not changing the username property of user , we are overwritting the whole user object. Our binding must reflect that and listen to changes on the entire user object. Up until this point we only used bindings with the same source and target type. GObject also allows transformation bindings, in which we bind properties with different types and provide a function to transform on type into the other. class HelloForm : Gtk.Grid { public User user { get; set; } construct { // ... bind_property (\"user\", label, \"label\", BindingFlags.DEFAULT, (binding, srcval, ref targetval) => { var user = (User) srcval.get_object (); targetval.set_string(\"Hello, %s!\".printf (user.username)); return true; }); } } Transformation functions receive GLib.Value , so we need to convert to the type of objects we need. Now our HelloForm reacts to a change in the application state in a complex way. And this concludes our experimentation with \"reactive\" Vala and GTK+ . I personally like this style of code much more than what I usually read in desktop GUI applications. What do you think? You can send comments here . If you liked this post consider buying me a coffe and/or following me on twitter at @igor_montagner .","title":"Vala reactive programming: part 2"},{"location":"blog/2021-12-24/#vala-reactive-programming-part-2","text":"In the last article we explored how to use properties and bindings to create reactive style programming in Vala. All UI code was written in construct and all logic was represented by setting properties. UI was synchronized with the Widget state by binding properties to child widgets. Although the separation of concerns was nice, the example was too simple. There was only one component (the LoginForm ) and no information was neither (i) sent to other components; or (ii) received from other components. In this article we'll create a second form that receives the validated user from LoginForm to a second form. All the example code for this article is available at the part2 folder in this github repo Our component architecture will be based on the following principle:","title":"Vala reactive programming: part 2"},{"location":"blog/2021-12-24/#if-two-components-share-a-parent-then-its-the-parents-resposability-to-connect-them-into-a-meaningful-flow-for-the-application","text":"Let's use this principle to extend the example from the last article and add a UserInfoForm after a succesful sign in. We'll start from the part2/v0.vala file.","title":"If two components share a parent, then it's the parent's resposability to connect them into a meaningful flow for the application"},{"location":"blog/2021-12-24/#dealing-with-events-inside-a-component","text":"Events are a place where UI and logic code seems hard to separate. It's quite natural, for instance, to create a login_btn_click event handler that uses both GUI calls to get information from the UI and properties. Fortunately, Vala also provides us with a very nice way of separating this: lambda functions as event handlers. private void do_login () { // check database and validate login here // GUI calls are forbidden here, only properties and other methods can be used } construct { // .... login_btn.clicked.connect (() => { // extract all info from the UI using GUI calls do_login (); }); } In the lambda event handler we can extract all info from the UI using GUI calls and then pass this information along to a method. Since we can use bindings to link information between properties and GUI elements, the amount of code inside the lambda event handler can be quite small. In fact, it might only treat the event information and pass it on to a method that uses it. Another interesting point is that lambda can ignore arguments and their types, so if we don't use the GEvent that the handler is supposed to receive we can just ignore it in our declaration. This has two advantages: do_login does not receive Gtk.Event (or similar), which means it can be called from anywhere in the code, not only in response to an user generated event. Event handlers often receive different arguments depending on which event they handle. The lambda handler is used to treat this arguments, so do_login is not tied to a single type of event.","title":"Dealing with events inside a component"},{"location":"blog/2021-12-24/#sending-information-out","text":"For sending information out of our components we can use signals . For instance, upon succesful login our LoginForm could emit a login_succesful signal that sends a User instance with the currently logged in user info. Now it's up to the parent of LoginForm to receive the signal and connect it to the next part of the application flow. First we modify LoginForm . For now our User class only contains the username property. Also, username is can only be assigned when creating an User instance. class User : Object { public string username { get; construct; } public User (string username) { Object (username: username); } } class LoginForm : Gtk.Grid { public signal void login_succesful (User u); // .... private void do_login() { login_succesful (new User (username)); } } Then we receive this information in our Application class: class Application : Gtk.Application { protected override void activate () { var win = new Gtk.ApplicationWindow (this); var login_form = new LoginForm (); login_form.login_succesful.connect ((u) => { print (\"%s\\n\", u.username); }); win.add (login_form); win.show (); } } The complete code is shown in part2/v1.vala .","title":"Sending information out"},{"location":"blog/2021-12-24/#intermission-application-mixes-ui-and-logic","text":"Our Application class is not following the principles outline in the last article . Let's fix that while we add a new Gtk.Stack to hold our new HelloForm . class HelloForm : Gtk.Grid { construct { expand = true; valign = Gtk.Align.CENTER; halign = Gtk.Align.CENTER; var label = new Gtk.Label (\"Hello (username goes here)\"); attach (label, 0, 0); } } Instead of creating widgets inside Application we introduce a ApplicationWidget , a class with the sole purpose of creating the workflow of data between our components. Our first version is shown below. class ApplicationWidget : Gtk.Stack { construct { // ... var login_form = new LoginForm (); add_named (login_form, \"login_form\"); var hello_form = new HelloForm (); add_named (hello_form, \"hello_form\"); visible_child_name = \"login_form\"; } } The complete code is shown in part2/v2.vala . Our application works exactly the same as before, but now UI is separated from the rest of the app in Application as well.","title":"Intermission: Application mixes UI and logic"},{"location":"blog/2021-12-24/#receiving-information-from-other-components","text":"For receiving information from the \"outside\" worlds we have two options: regular instance methods or public properties. The advantage of using instance methods is that they can be directly connected to other components' signals. However, we must take care of only updating properties inside it so we don't mix UI and logic. We can also use public properties to receive data from the \"outside world\". Use methods if something besides updating the UI is necessary (i.e. pulling information from the database or the web) Use properties otherwise We add a user property to HelloForm so it can receive the currently logged in user. We then connect the components in our ApplicationWidget : class HelloForm : Gtk.Grid { public User user { get; set; } // ... } class ApplicationWidget : Gtk.Stack { construct { // ... login_form.login_succesful.connect ((u) => { hello_form.user = u; visible_child_name = \"hello_form\"; }); } } The final part of this is to connect a change in HelloForm.user with the UI. A first could be creating a binding between user.username to the label text. This won't work, as we are not changing the username property of user , we are overwritting the whole user object. Our binding must reflect that and listen to changes on the entire user object. Up until this point we only used bindings with the same source and target type. GObject also allows transformation bindings, in which we bind properties with different types and provide a function to transform on type into the other. class HelloForm : Gtk.Grid { public User user { get; set; } construct { // ... bind_property (\"user\", label, \"label\", BindingFlags.DEFAULT, (binding, srcval, ref targetval) => { var user = (User) srcval.get_object (); targetval.set_string(\"Hello, %s!\".printf (user.username)); return true; }); } } Transformation functions receive GLib.Value , so we need to convert to the type of objects we need. Now our HelloForm reacts to a change in the application state in a complex way. And this concludes our experimentation with \"reactive\" Vala and GTK+ . I personally like this style of code much more than what I usually read in desktop GUI applications. What do you think? You can send comments here . If you liked this post consider buying me a coffe and/or following me on twitter at @igor_montagner .","title":"Receiving information from other components"}]}