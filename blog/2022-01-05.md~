# Vala reactive programming: part 3

The last article showed how we could create a Window with two different forms with clear separation between application logic and GUI code. Most of our work consisted of binding properties and using signals to send information out of components. Although this seems to work well with our little example, our application didn't have any global state. One could argue that global state is a code smell (and a lot of people do), but the fact is that lot's of applications use it to some degree. 

One of the problems of global state is that it increases **coupling**. Essentially, **coupling** represents the amount of interdependency between two or more modules. Frequently, in situations with large **coupling** a change in one module snowballs into lots changes in the related modules as well. This is why **coupling** is seen as bad: there's the possibility of a butterfly effect in which a small change in one module produces a large change overall. 

So, now that the 

## Vala Memory Management


